"
I am the superclass of all scriptable Scratch morphs.

Scriptable morphs:
  1. allow the user to add user-defined scripts
  2. allow the user to add user-defined variables
  3. when they are copied, their scripts and variables are copied;
     thereafter, script changes to the original and the copy are entirely independent
  4. can be exported and imported into another Scratch project.

"
Class {
	#name : #ScriptablePhratchMorph,
	#superclass : #Morph,
	#instVars : [
		'objName',
		'vars',
		'lists',
		'blocksBin',
		'isClone',
		'media',
		'costume',
		'costumeChangeMSecs',
		'filterPack',
		'visibility',
		'volume',
		'sceneStates',
		'customBlocks',
		'deletedAttributes',
		'colors',
		'phratchModel'
	],
	#classVars : [
		'BlockVisible',
		'CameraOpenings',
		'DefaultBackgroundForm',
		'DoubleSize',
		'FileIOPreference',
		'KeepOnStage',
		'MeowSound',
		'NoviceMode',
		'PhratchOrigin',
		'PopSound',
		'Recorder',
		'TimerStartMSecs',
		'TraceMode'
	],
	#category : #'Phratch-Objects'
}

{ #category : #deprecated }
ScriptablePhratchMorph class >> blockColorFor: aCategory [
	"Answer the block color for the given category."
	self deprecated: 'use PhratchCategory blockColorFor:'.
	^(PhratchCategory allSubclasses detect:[:e | e label = aCategory] ifNone: [PhratchCategory]) color.

]

{ #category : #'panther-actions' }
ScriptablePhratchMorph class >> blockVisible [

	^ BlockVisible
]

{ #category : #'panther-actions' }
ScriptablePhratchMorph class >> blockVisible: aBlockName [

	(self isBlockVisible: aBlockName) ifTrue:[ 
		BlockVisible add: aBlockName]
	ifFalse:[
		BlockVisible remove: aBlockName ifAbsent:[]
		]
]

{ #category : #'panther-actions' }
ScriptablePhratchMorph class >> cameraOpened [

	CameraOpenings := ((CameraOpenings ifNil: [0]) max: 0) + 1.
]

{ #category : #'panther-actions' }
ScriptablePhratchMorph class >> closeCamera [
	CameraOpenings := (CameraOpenings - 1) max: 0.
	CameraOpenings = 0 ifTrue: [CameraPlugin closeCamera: 1].
]

{ #category : #'forms/sounds/icons' }
ScriptablePhratchMorph class >> defaultBackgroundForm [

	(DefaultBackgroundForm isNil or:
	 [DefaultBackgroundForm extent ~= PhratchFrameMorph workpaneExtent]) ifTrue: [
		DefaultBackgroundForm := (Form extent: PhratchFrameMorph workpaneExtent depth: 1).
		DefaultBackgroundForm fillWhite].

	^ DefaultBackgroundForm

]

{ #category : #byob }
ScriptablePhratchMorph class >> doMakeNewList [
	^nil
]

{ #category : #other }
ScriptablePhratchMorph class >> doubleSize: aBoolean [

	DoubleSize := aBoolean.

]

{ #category : #accessing }
ScriptablePhratchMorph class >> fileIOPreference [
	^ FileIOPreference  ifNil: [ FileIOPreference := true ]
]

{ #category : #accessing }
ScriptablePhratchMorph class >> fileIOPreference: anObject [
	FileIOPreference := anObject
]

{ #category : #other }
ScriptablePhratchMorph class >> fromUser [
	"Go into a mode asking the user to select an instance of me, displaying a crossHair cursor while in this mode. The mode ends with the next mouse click. If the click is over an instance of me, return it. Otherwise, return nil. Keep running the world while waiting for the mouse click."

	| result p m mList |
	World ifNil: [^ self].  "not in morphic"
	result := nil.
	Cursor crossHair showWhile: [
		[Sensor anyButtonPressed] whileFalse: [World doOneCycleNoInput].
		p := Sensor cursorPoint.
		m := (World rootMorphsAt: p) first.
		(m isPhratchFrameMorph) ifTrue: [
			mList := m workPane rootMorphsAt: p.
			mList size > 0 ifTrue: [
				m := (m workPane rootMorphsAt: p) first]].
		(m isKindOf: self) ifTrue: [result := m].
		Sensor waitNoButton].
	^ result

]

{ #category : #'class initialization' }
ScriptablePhratchMorph class >> initialize [
	"self initialize"

	PhratchOrigin := 0@0.
	TimerStartMSecs := Time millisecondClockValue.
	BlockVisible := Set new.
	TraceMode := false.
	DoubleSize := false
]

{ #category : #'panther-actions' }
ScriptablePhratchMorph class >> isBlockVisible: aBlockName [

	^ (BlockVisible includes: aBlockName) not.
	
]

{ #category : #other }
ScriptablePhratchMorph class >> isSpriteSpecificTarget: anObject selector: selector [
	"I determine whether the given selector is specific to a particular Sprite. ."

	| i |
	
	self flag: 'This is crappy, it gives another receiver than the one expected. Should be removed, but carefully '.
	(anObject isPhratchSpriteMorph) ifFalse: [^ false].
	i := selector asString
		findAnySubstring: #('answer' 'key' 'Loud' 'mouse' 'soundLevel' 'tempo' 'timer')
		startingAt: 1.
	^ i > selector asString size

]

{ #category : #byob }
ScriptablePhratchMorph class >> keepOnStage [

	^KeepOnStage ifNil: [true ]
]

{ #category : #byob }
ScriptablePhratchMorph class >> keepOnStage: aBool [
	KeepOnStage := aBool
]

{ #category : #accessing }
ScriptablePhratchMorph class >> noviceMode [
	^ NoviceMode  ifNil: [ NoviceMode := false ]
]

{ #category : #accessing }
ScriptablePhratchMorph class >> noviceMode: anObject [
	NoviceMode := anObject
]

{ #category : #other }
ScriptablePhratchMorph class >> phratchOrigin: aPoint [
	"Set the origin for the Phratch coordinate system."

	PhratchOrigin := aPoint.

]

{ #category : #other }
ScriptablePhratchMorph class >> resetTimer [

	TimerStartMSecs := Time millisecondClockValue.

]

{ #category : #other }
ScriptablePhratchMorph class >> stopSoundRecorder [
	"Stop the shared sound recorder."
	"self stopSoundRecorder"

	Recorder ifNotNil: [Recorder stopRecording; clearRecordedSound].


]

{ #category : #accessing }
ScriptablePhratchMorph class >> traceMode [
	^ TraceMode  ifNil: [ TraceMode := false ]
]

{ #category : #accessing }
ScriptablePhratchMorph class >> traceMode: anObject [
	TraceMode := anObject
]

{ #category : #byob }
ScriptablePhratchMorph >> & aBoolean [
	"boolean operator '&'. It combines two booleans and returns a boolean"
	<phratchItem: '$Boolean$ and $Boolean$' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a4 special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> \\ aNumber [
	"Modulo operator. It returns the modulo of two numbers"
	<phratchItem: '$Number$ mod $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(- -) subCategory: #a1 special: #()>

]

{ #category : #scripts }
ScriptablePhratchMorph >> addComment: aPhratchCommentMorph [
	"Aligns the newly added script below the lowest script in the pane."

	| y bottom |
	y := 10.
	blocksBin
		submorphsDo: [ :m | 
			bottom := m fullBounds bottom - blocksBin position y.
			y := y max: bottom ].
	aPhratchCommentMorph position: blocksBin position + (20 @ (y + 10)).
	blocksBin addMorph: aPhratchCommentMorph
]

{ #category : #byob }
ScriptablePhratchMorph >> addCustomBlock [
	|ans def sf|
	(sf := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^self].
	BlockDialog isOpen ifTrue: [^ self].
	ans := BlockDialog ask: 'Make a block' localized.
	(ans = #cancelled) ifTrue: [^self ].

	def := (CustomBlockDefinition new 
		userSpec: (ans at: 1);
		category: (ans fourth = #other ifTrue: [#none] ifFalse: [ans fourth]);
		yourself).
	(ans at: 2)	
		ifTrue: [ (ans at: 3) 
			ifTrue: [def type: #boolean]
			ifFalse: [def type: #any]]
		ifFalse: [def type: #none; isAtomic: false].
	def isGlobal: (ans at: 5) not.

	(self existsBlockId: (CustomBlockDefinition idFromSpec: (ans at: 1)) global: (ans at: 5))
			ifTrue: [^DialogBoxMorph warn: 'a custom block with this label already exists' localized].

	self ensureCustomBlockExists: def global: def isGlobal.

	sf projectModified. 
	sf viewerPane categoryChanged: 'variables'.
	#none = def category ifFalse: [
		sf viewerPane categoryChanged: def category asString ].
	self editScriptId: (CustomBlockDefinition idFromSpec: (ans at: 1)).
]

{ #category : #byob }
ScriptablePhratchMorph >> addCustomBlocksTo: page y: startY [
	| addButton x y b cdefs inherited all |
	addButton := PhratchFrameMorph buttonLabel: 'Make a block' localized selector: #addCustomBlock.
	x := 13.
	y := startY + 10.
	page
		addMorph:
			(addButton
				target: self;
				position: x @ y;
		yourself).
	y := addButton bottom + 5.	"add custom blocks (jens)"
	inherited := self inheritedBlocks select: [ :def | def category = #none ].
	customBlocks ifNil: [ cdefs := Set new ] ifNotNil: [ cdefs := customBlocks select: [ :def | def category = #none ] ].
	all := inherited , cdefs.
	all isEmpty
		ifTrue: [ ^ self ].
	all := all asSortedCollection: [ :first :second | first id <= second id ].
	all
		do: [ :eachDef | 
			b := self newCustomBlockFor: eachDef.
			page addMorph: (b position: x @ y).
			y := y + b height + 3 ]
]

{ #category : #blocks }
ScriptablePhratchMorph >> addEventNamesTo: aSet [
	"Add the names of all events implemented by this morph, excluding keyboard events. Suppress duplicates (ignoring case differences)."

	| allCustomBlockMorphs |
	(blocksBin isMorph) ifFalse: [^ self].

	allCustomBlockMorphs := OrderedCollection new.
	customBlocks ifNotNil: [customBlocks do: [:cb | cb allBlocks do: [:ab |
		allCustomBlockMorphs addAll: ab allMorphs]]].

	blocksBin allMorphs, allCustomBlockMorphs do: [:m |
		(m class = EventTitleMorph) ifTrue: [
			(aSet anySatisfy: [:el | el caseInsensitiveEqual: m eventName]) ifFalse: [
				aSet add: m eventName]]].

]

{ #category : #blocks }
ScriptablePhratchMorph >> addGenericVariableBlocksTo: page x: x y: startY [
	"Add the generic variable blocks to the given page starting at the given y offset. Answer the new y."

	| y vName stage block varBlocks |
	y := startY.	"pick a default variable name"
	vName := nil.
	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	vName := (stage notNil and: [ stage varNames size > 0 ])
		ifTrue: [ stage varNames first ]
		ifFalse: [ 
			self varNames size = 0
				ifTrue: [ ''	"^ y" ]
				ifFalse: [ self varNames first ] ].
	vName ifNil: [ vName := '' ].
	varBlocks := OrderedCollection new.
	(self blocksFor: 'variables')
		do: [ :b | 
			(b isBlockMorph)
				ifTrue: [ b defaultArgs: (Array with: vName) ].
			varBlocks add: b ].
	block := VariableDeclarationBlockMorph new
		minArgs: 1;
		commandSpec: 'script variables' localized;
		receiver: self blockReceiver;
		addItem;
		isSpecialForm: true;
		selector: #doDeclareVariables;
		yourself.
	varBlocks add: block afterIndex: 5.
	varBlocks
		do: [ :blockOrSym | 
			({#- . #~ . #=} includes: blockOrSym)
				ifTrue: [ 
					blockOrSym = #-
						ifTrue: [ y := y + 15 ].	"insert a full space"
					blockOrSym = #~
						ifTrue: [ y := y + 5 ].	"insert a half space"
					blockOrSym = #=
						ifTrue: [ 
							y := y + 7.
							page addMorph: ((ImageMorph new form: (PhratchFrameMorph skinAt: #connector)) position: x @ y).
							y := y + 20 ] ]
				ifFalse: [ 
					blockOrSym
						color:
							((blockOrSym isVariableDeclarationBlockMorph)
								ifTrue: [ Color gray ]
								ifFalse: [ self variableBlockColor ]).
					page addMorph: (blockOrSym position: x @ y).
					y := blockOrSym bottom + 3 ]	"insert a line" ].	"


[:b |
		b color: self variableBlockColor.
		page addMorph: (b position: x@y).
		y := b bottom + 3].
"
	^ y
]

{ #category : #variables }
ScriptablePhratchMorph >> addGlobalVariable [
	"Ask the user for a variable name, then add a background (global) variable of that name."

	| sFrame varName |
	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ PhratchError error: 'beep'.].

	varName := StringDialog ask: 'Variable name?'.
	varName size = 0 ifTrue: [^ self].
	varName := varName.
	(sFrame workPane variableNameInUse: varName) ifTrue: [
		PhratchError error: 'beep'.
		DialogBoxMorph warn: 'That variable name is already in use'.
		^ self].

	sFrame workPane addVariable: varName.
	sFrame viewerPane categoryChanged: 'variables'.
	self addWatcherForNewVariable: varName withScope: sFrame workPane.

]

{ #category : #media }
ScriptablePhratchMorph >> addMediaItem: aPhratchMedia [
	"Add the given media item to my media."

	aPhratchMedia mediaName: (self unusedMediaNameFromBaseName: aPhratchMedia mediaName).
	media addLast: aPhratchMedia.
	aPhratchMedia isSound ifFalse: [self lookLike: aPhratchMedia mediaName].
	self updateMediaCategory.
]

{ #category : #scripts }
ScriptablePhratchMorph >> addStack: aBlockStack [
	"Aligns the newly added script below the lowest script in the pane."

	| y bottom |
	y := 10.
	blocksBin
		submorphsDo: [ :m | 
			bottom := m fullBounds bottom - blocksBin position y.
			y := y max: bottom ].
	aBlockStack position: blocksBin position + (20 @ (y + 10)).
	aBlockStack newScriptOwner: self.
	blocksBin addMorph: aBlockStack
]

{ #category : #byob }
ScriptablePhratchMorph >> addVariable [
	"Ask the user for a variable name, then add a user variable of that name. This version is for sprites and supports the option of making the variable specific to the sprite (i.e. local)."

	| sFrame result varName varOwner w |
	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ PhratchError error: 'beep'.].

	result := NewVariableDialog ask: 'Variable name?'.
	result = #cancelled ifTrue: [^ self].
	varName := result first.
	varOwner := result second ifTrue: [self] ifFalse: [sFrame workPane].
	(varOwner variableNameInUse: varName) ifTrue: [
		PhratchError error: 'beep'.
		DialogBoxMorph warn: 'That variable name is already in use'.
		^ self].

	varOwner addVariable: varName.
	sFrame viewerPane categoryChanged: 'variables'.
	self addWatcherForNewVariable: varName withScope: varOwner.

	w := sFrame watcherForBlock: (VariableBlockMorph new receiver: self; commandSpec: varName; yourself).
	w ifNotNil: [w setCategoryColor: (PhratchCategory blockColorFor: 'variables')].


]

{ #category : #variables }
ScriptablePhratchMorph >> addVariable: varName [
	"Add a new variable with the given name locale to the object. Do nothing if the variable already exists or is built in."
	<phratchItem: 'make $String$' kind: #- category: 'variables' defaultValues: #('a variable') subCategory: #a1 special: #()>
	| sFrame |
	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ PhratchError error: 'beep'.].
	(vars includesKey: varName asString) ifFalse: [
		vars at: varName asString put: 0].
	self isClone: false.
	sFrame viewerPane categoryChanged: 'variables'.
	self addWatcherForNewVariable: varName withScope: sFrame workPane
]

{ #category : #variables }
ScriptablePhratchMorph >> addVariable: varName value: anObject [
	"Add a new user variable with the given name to this object. Do nothing if the variable already exists or is built in."

	(vars includesKey: varName asString) ifFalse: [
		vars at: varName asString put: anObject].
	self isClone: false.

]

{ #category : #blocks }
ScriptablePhratchMorph >> addVariableReportersTo: page x: x y: startY [
	"Add the list block reporters to the given page starting at the given y offset. Answer the new y."

	| y stage b watcherButton yOffset line line2 |
	y := startY.

	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	(stage notNil and: [stage ~= self]) ifTrue: [
		stage varNames do: [:vName |
			b := VariableBlockMorph new
				commandSpec: vName;
				receiver: stage blockReceiver;
		yourself.

			watcherButton := self createToggleButtonFor: b.
			yOffset := (b fullBounds height - watcherButton height) // 2.
			page addMorph: (watcherButton position: x @ (y + yOffset)).
			page addMorph: (b position: (x + watcherButton width + 4)@y).
			y := y + b height + 3].
		(self varNames size > 0) ifTrue: [
			line := Morph new.
			line
				extent: 90@1;
				color: Color gray darker darker;
				position: x@(y+2).
			line2 := Morph new.
			line2
				extent: 90@1;
				color: Color gray lighter;
				position: x@(y+3).
			page
				addMorph: line;
				addMorph: line2.
			y := y + 9]].

	self varNames do: [:vName |
		b := VariableBlockMorph new
			commandSpec: vName;
			receiver: self blockReceiver;
		yourself.

		watcherButton := self createToggleButtonFor: b.
		yOffset := (b fullBounds height - watcherButton height) // 2.
		page addMorph: (watcherButton position: x @ (y + yOffset)).
		page addMorph: (b position: (x + watcherButton width + 4)@y).
		y := y + b height + 3].

	^ y

]

{ #category : #variables }
ScriptablePhratchMorph >> addWatcherForNewVariable: varName withScope: spriteOrStage [
	"Add a watcher on the stage once a variable has been created."

	| sFrame |
	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ self].
	sFrame viewerPane pageViewer submorphs do: [:s | 
		(s isPhratchBlockPaletteMorph) ifTrue: [
			s submorphs do: [:block | 
				(block isVariableBlockMorph) ifTrue: [
					(block receiver = spriteOrStage) &
					(block commandSpec = varName) ifTrue: [
						(sFrame watcherForBlock: block) ifNil: [
							block toggleWatcher]]]]]].

]

{ #category : #byob }
ScriptablePhratchMorph >> allInstancesOf: aCustomBlockId [
	| objects stage all |
	stage := (self isPhratchStageMorph)
		ifTrue: [ self ]
		ifFalse: [ self owner ].
	objects := {stage} , stage sprites.
	all := OrderedCollection new.
	objects do: [ :obj | all addAll: (obj instancesOf: aCustomBlockId) ].
	^ all
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> allLocalBlockIds [

	| ownIds inheritedIds |
	ownIds := self blockIds.
	self prototype ifNil: [^ ownIds].
	inheritedIds := (self prototype localBlocks collect: [:each | 
		each id ]) reject: [:id |
			ownIds includes: id].
	^ (ownIds, inheritedIds) asSortedCollection
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> allSprites [

	| stage |
	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ifNil: [^ PhratchListMorph new].
	^ PhratchListMorph on: stage sprites
]

{ #category : #variables }
ScriptablePhratchMorph >> allVarNames [
	"Answer a set of all variable and list variable names."

	| allNames |
	allNames := vars keys asSet.
	allNames addAll: lists keys.
	^ allNames


]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> answer [
	"Return the latest answer given by the user. An answer should be given when one of the blocks 'ask...' is executed."
	<phratchItem: 'answer' kind: #ReporterWatcherBlockMorph category: 'sensing' defaultValues: #() subCategory: #a1 special: #()>
	^ PhratchPrompterMorph lastAnswer

]

{ #category : #'list ops' }
ScriptablePhratchMorph >> asListElement: anObject [
	"Answer the given object converted to an object suitable for storing in a list."

	(anObject isScriptablePhratchMorph) ifTrue: [^ anObject].
	(anObject isBlockMorph) ifTrue: [^ anObject].
	(anObject isPhratchListMorph) ifTrue: [^ anObject].
	(anObject isString) ifTrue: [^ anObject].
	(anObject isCharacter) ifTrue: [^ anObject asString].

	(anObject isBoolean) ifTrue: [
		^ anObject].

"
	(anObject isBoolean) ifTrue: [
		^ anObject ifTrue: ['1'] ifFalse: ['0']].
"

	^ anObject "printString"


]

{ #category : #byob }
ScriptablePhratchMorph >> asciiCodeOf: aString [
	"It gives the ascii code of a character"
	<phratchItem: 'ascii code of $String$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('a') subCategory: #a7 special: #()>
	| str |
	str := aString.
	str size = 1 ifFalse: [
		^ 0 ].
	^ str first asciiValue
]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> asciiFor: keyName [

	| localizedKey |
	keyName size = 1 ifTrue: [^ keyName first asciiValue].

	localizedKey := keyName localized.
	'space' localized = localizedKey ifTrue: [^ Character space asciiValue].
	'enter' localized = localizedKey ifTrue: [^ Character cr asciiValue].
	'up arrow' localized = localizedKey ifTrue: [^ 30].
	'down arrow' localized = localizedKey ifTrue: [^ 31].
	'right arrow' localized = localizedKey ifTrue: [^ 29].
	'left arrow' localized = localizedKey ifTrue: [^ 28].

	"needed to support old projects:"
	'up' = keyName ifTrue: [^ 30].
	'down' = keyName ifTrue: [^ 31].
	'right' = keyName ifTrue: [^ 29].
	'left' = keyName ifTrue: [^ 28].

	^ -1  "no match; should never happen"

]

{ #category : #byob }
ScriptablePhratchMorph >> asciiLetter: anInteger [
	"Convert an ascii number into a letter"
	<phratchItem: 'ascii $Number$ as letter' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('65') subCategory: #a7 special: #()>
	| code |
	code := anInteger asNumberNoError.

	^ String with: (Character value: code)
]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> attributeNames [

	^ vars keys

]

{ #category : #blocks }
ScriptablePhratchMorph >> blockCategories [
	"Answer a list of block categories."

	^ (phratchModel class blockSpecs select: [:el |
		(el isString) and: [el ~= '-' and: [el ~= '~']]]) asArray

]

{ #category : #'BYOB OOP message passing' }
ScriptablePhratchMorph >> blockForSelector: aSymbol [
	"Answer a block for the give selector or nil"

	| cat |

	phratchModel class blockSpecs do: [:spec |
		((spec isSymbol) not and: [spec isString])
			ifTrue: [cat := spec].

		((spec isArray) and: [(spec at: 3) = aSymbol])
			ifTrue: [^ self blockFromSpec: spec color: (PhratchCategory blockColorFor: cat)]].

	^ nil



]

{ #category : #utilities }
ScriptablePhratchMorph >> blockFromSpec: spec color: blockColor [
	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."

	|  blockType block special |
	blockType := spec at: 2.
	
	blockType = #- ifTrue:[
		spec at:2 put: #CommandBlockMorph.
		blockType := #CommandBlockMorph.
	].
	
	block := (Smalltalk at: blockType) blockTypeOn: self spec: spec.
	
	special :=  spec at: 4.
	special do:[:sel |
		block perform: sel.
	].

	^ (Smalltalk at: blockType) initBlock: block on: self withSpec: spec color: blockColor
]

{ #category : #byob }
ScriptablePhratchMorph >> blockIds [
	customBlocks ifNil: [ customBlocks := OrderedCollection new ].
	^ (customBlocks reject: [ :eachDef | eachDef isGlobal ]) collect: [ :eachDef | eachDef id ]
]

{ #category : #blocks }
ScriptablePhratchMorph >> blockReceiver [
	"Answer the object that is the receiver of my blocks. By default that is myself, but subclasses may re-direct block operations to another object."

	^ self

]

{ #category : #blocks }
ScriptablePhratchMorph >> blockSpecForSelector: aSymbol [
	"Answer a block specification string (in English) for the give selector or nil if there is no spec that has the given selector."

	phratchModel class blockSpecs do: [:spec |
		((spec isArray) and: [(spec at: 3) = aSymbol])
			ifTrue: [^ spec first]].

	^ nil

]

{ #category : #blocks }
ScriptablePhratchMorph >> blocksBin [

	^ blocksBin

]

{ #category : #blocks }
ScriptablePhratchMorph >> blocksFor: aCategory [
	"Answer a collection of blocks for the given category. Mixed with the blocks are dash and tilde symbols (#- and #~) indicating where full and half spaces should be inserted when laying out the blocks."

	| blockColor blocksList category b cdefs inherited all |
	blockColor := PhratchCategory blockColorFor: aCategory.
	blocksList := OrderedCollection new.
	category := nil.
	phratchModel class blockSpecs do: [:spec |
		((spec isString) and: [spec ~= #- and: [spec ~= #~ and: [spec ~= #=]]])
			ifTrue: [category := spec]
			ifFalse: [
				category = aCategory ifTrue: [
					({#- . #~ . #=} includes: spec)
						ifTrue: [blocksList addLast: spec]
						ifFalse: [
							(b := self blockFromSpec: spec color: blockColor) ifNotNil: [
								blocksList addLast: b]]]]].

	"add custom blocks (jens)"
	inherited := self inheritedBlocks select: [:def |
		def category = aCategory asSymbol ].

	customBlocks 
		ifNil: [cdefs := Set new]
		ifNotNil: [ cdefs := customBlocks select: [:def | 
			def category = aCategory asSymbol]].

	all := inherited, cdefs.
	all isEmpty ifFalse: [
		blocksList
			add: #=.
		all := all asSortedCollection: [:x :y | x commandSpec <= y commandSpec].
		blocksList addAll: (all collect: [:each | self newCustomBlockFor: each ])].

	^ blocksList asArray

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> broadcast: name [
	"Broadcast the given event name."
	<phratchItem: 'broadcast $Event$' kind: #- category: 'control' defaultValues: #() subCategory: #broadcast special: #()>
	self broadcast: name withArgument: 0.

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> broadcast: name withArgument: arg [
	"Broadcast the given event with the given argument."

	| stage |
	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [
		stage broadcastEventNamed: name asString with: arg].

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> cameraIsOpen [
	"return true if the camera is open"
	<phratchItem: 'camera is open?' kind: #BooleanWatcherBlockMorph category: 'looks' defaultValues: #() subCategory: #a9 special: #()>
	^ CameraPlugin cameraIsOpen: 1.
]

{ #category : #variables }
ScriptablePhratchMorph >> changeVar: varName by: increment [
	"Change the value of the given variable of this object by the given amount."
	<phratchItem: 'change $Variable$ by $Number$' kind: #- category: 'variables' defaultValues: #('' 1) subCategory: #a0 special: #()>
	| stage n frame w |

	(vars includesKey: varName asString) ifFalse: [
		stage := self ownerOrYourselfThatIsAPhratchStageMorph.
		(stage notNil and: [stage ~= self]) 
			ifTrue: [stage changeVar: varName by: increment].
		(self prototype notNil and: [self prototype varNames includes: varName])
			ifTrue: [
				vars at: varName put: (self getVar: varName) + increment asNumberNoError.
			frame := self phratchFrame.
			frame ifNil: [^ self].
			frame viewerPane categoryChanged: 'variables'.
			w := frame watcherForBlock: (VariableBlockMorph new 
					receiver: self; 
					commandSpec: varName; 
					yourself).
			w ifNotNil: [
				w setCategoryColor: (PhratchCategory blockColorFor: 'variables') ].
			^self.
		]].

	n := vars at: varName asString ifAbsent: [^ self].
	self setVar: varName to: n asNumberNoError + increment asNumberNoError.

]

{ #category : #widgets }
ScriptablePhratchMorph >> changed [
	"Report that the area occupied by this morph should be redrawn."
	self invalidRect: self fullBounds.

]

{ #category : #'block API' }
ScriptablePhratchMorph >> checkNil: str [
	"Verify if the given value is nil"
	<phratchItem: 'is $String$ nil?' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a9 special: #()>
	^ str isNil
]

{ #category : #private }
ScriptablePhratchMorph >> clearMediaAndCostume [
	"Private! Used when exporting an empty stage."

	media := OrderedCollection new.
	costume := nil.

]

{ #category : #'pen ops' }
ScriptablePhratchMorph >> clearPenTrails [

	self subclassResponsibility 
]

{ #category : #byob }
ScriptablePhratchMorph >> clearVariables [

	self varNames do: [:vn |
		self setVar: vn to: 0].

	self listVarNames do: [:ln |
		(self listNamed: ln) clear]
]

{ #category : #'event handling' }
ScriptablePhratchMorph >> click: evt [
	"Start or stop all my clickable scripts."

	| h clickEvt |
	h := World activeHand.
	h toolType ifNotNil: [^ self handleTool: h toolType hand: h].

	clickEvt := PhratchEvent new
		name: 'Phratch-MouseClickEvent'
		argument: 0.
	self eventReceived: clickEvt.

]

{ #category : #byob }
ScriptablePhratchMorph >> closeBlockEditor [
	| sf |
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNil: [^self].
	^sf closeBlockEditor
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> closeCamera [

	self class closeCamera.
]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> coerceSpriteArg: anObject [
	"Coerce the given object to a sprite reference if necessary. If it is a Symbol (e.g. #mouse), just return it. If it is a String, try to find a Sprite with that name. If it is a Number, coerce it to a string and look for a Sprite with a matching name."

	| s targetName |
	(anObject isScriptablePhratchMorph) ifTrue: [^ anObject].
	(anObject isSymbol) ifTrue: [^ anObject].

	targetName := anObject isNumber ifTrue: [anObject printString] ifFalse: [anObject].

	(s := self ownerOrYourselfThatIsAPhratchStageMorph) ifNil: [^ nil].
	s submorphsDo: [:m |
		((m isScriptablePhratchMorph) and:
		 [targetName = m objName])
			ifTrue: [^ m]].

	^ nil


]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> comeToFront [

	super comeToFront.
	self setLayerTo: 1
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> computeFunction: functionName of: aNumber [
	"Return the result of computing the given mathematical function on the given number."
	<phratchItem: '$MathFunctions$ of $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('sqrt' 10) subCategory: #a1 special: #()>
	'abs' = functionName ifTrue: [^ aNumber abs].
	'sqrt' = functionName ifTrue: [^ aNumber sqrt].
	'sin' = functionName ifTrue: [^ aNumber degreesToRadians sin].
	'cos' = functionName ifTrue: [^ aNumber degreesToRadians cos].
	'tan' = functionName ifTrue: [^ aNumber degreesToRadians tan].
	'asin' = functionName ifTrue: [^ (aNumber within: -1.0 and: 1.0) arcSin radiansToDegrees].
	'acos' = functionName ifTrue: [^ (aNumber within: -1.0 and: 1.0) arcCos radiansToDegrees].
	'atan' = functionName ifTrue: [^ aNumber arcTan radiansToDegrees].
	
	'ln' = functionName ifTrue: [^ aNumber ln].
	'log' = functionName ifTrue: [^ aNumber log].
	'e ^' = functionName ifTrue: [^ aNumber exp].
	'10 ^' = functionName ifTrue: [^ 10.0 raisedTo: aNumber].

	^ 0

]

{ #category : #'string ops' }
ScriptablePhratchMorph >> concatenate: arg1 with: arg2 [
	"Concatenate two strings. Arguments are converted to strings."
	<phratchItem: 'join $String$ and $String$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('hello ' 'world') subCategory: #a6 special: #()>
	^ arg1 asString, arg2 asString

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> constantNames [
	"Answer the names of supported constants"

	^ #(
		'pi'
		'e'
		'newline'
		'tab')
]

{ #category : #private }
ScriptablePhratchMorph >> copyForExport [
	"Answer a copy of me for exporting."

	| objToExport |
	objToExport := self fullCopy.
	objToExport objName: objName.
	objToExport prepareForExport.
	^ objToExport

]

{ #category : #accessing }
ScriptablePhratchMorph >> costume [

	^ costume

]

{ #category : #accessing }
ScriptablePhratchMorph >> costumeChangeMSecs [
	"Answer the time of the last costume change. Whenever a costume change (or a filter change) occurs, this value is updated from the current millisecond clock. This value is used to optimize redrawing of thumbnails--if costumeChangeMSecs hasn't changed since the last time the thumbnail was updated we don't need to compute a new thumbnail."

	^ costumeChangeMSecs

]

{ #category : #accessing }
ScriptablePhratchMorph >> costumeForm [
	"Answer my current costume form, without filtering, rotation or scaling. If my costume is a movie or animation, answer the appropriate frame."

	^ costume compositeForm

]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> costumeFromName: aString [
	"If there is a costume by the given name, return it. Otherwise, return nil."

	| cameraCostume |
	((aString = '*** camera ***') and:
	 [CameraPlugin cameraIsAvailable]) ifTrue: [
		self halt.
		cameraCostume := CameraMedia new.
		(self class = PhratchStageMorph) ifTrue: [cameraCostume frameExtent: self extent].
		^ cameraCostume].

	^ media
		detect: [:el | el isSound not and: [el mediaName = aString or: [el mediaName = aString]]]
		ifNone: [nil]

]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> costumeIndex [
	"Answer the index of my current costume."
	| att |
	att := #costumeIndex.
	self prototype ifNotNil: [
		(self deletedAttributes includes: att) ifTrue: [
			^ self prototype get: att]].

	^ (media reject: [:m | m isSound])
		indexOf: costume ifAbsent: [1]

]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> costumeNameFromNumber: aNumber [
	"Return a costume name for the given number--rounded and modulo the number of costumes."

	| costumeList i |
	costumeList := media reject: [:m | m isSound].
	costumeList size = 0 ifTrue: [^ 'costume'].

	i := ((aNumber rounded - 1) \\ costumeList size) + 1.
	^ (costumeList at: i) mediaName

]

{ #category : #media }
ScriptablePhratchMorph >> costumeNames [
	"Answer a list of my costume (costume = non-sound media object) names."

	| result nm |
	result := OrderedCollection new.
	media do: [:el |
		el isSound ifFalse: [
			nm := el mediaName.
			(result includes: nm) ifFalse: [result add: nm]]].

	result := result asArray.
	CameraPlugin cameraIsAvailable ifTrue: [
		result := result copyWith: '*** camera ***'].
	^ result

]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> costumes [
	"this will at some future time answer first class costumes,
	for now it's just the costume names"

	^ PhratchListMorph on: ((media reject: [ :m | m isSound ]) collect: [ :c | c mediaName ])
]

{ #category : #blocks }
ScriptablePhratchMorph >> costumesPage: xOffset [
	"Answer a morph containing thumbnails of my costumes."

	| bin label m y images n recBut impBut photoBut maxHeight xMargin yMargin separator |
	xMargin := 15.
	yMargin := 15.
	bin := PhratchBlockPaletteMorph new color: PhratchFrameMorph scriptsPaneColor.
	label := (self isPhratchStageMorph)
		ifTrue: [ 'New background:' localized ]
		ifFalse: [ 'New costume:' localized ].
	m := StringMorph contents: label font: (PhratchFrameMorph getFont: #CostumesPage).
	m color: Color white.
	bin addMorph: m.
	recBut := PhratchFrameMorph buttonLabel: 'Paint' localized selector: #drawNewCostume.
	recBut target: self.
	bin addMorph: recBut.
	impBut := PhratchFrameMorph buttonLabel: 'Import' localized selector: #importImage.
	impBut target: self.
	bin addMorph: impBut.
	photoBut := PhratchFrameMorph buttonLabel: 'Camera' localized selector: #takePhoto.
	photoBut target: self.
	bin addMorph: photoBut.
	maxHeight := m height max: (impBut height max: (recBut height max: photoBut height)).
	 
	m position: xMargin @ (yMargin + ((maxHeight - m height) / 2)).
	recBut position: (m right + 4) @ (yMargin + ((maxHeight - recBut height) / 2)).
	impBut position: (recBut right + 4) @ (yMargin + ((maxHeight - impBut height) / 2)).
	photoBut position: (impBut right + 4) @ (yMargin + ((maxHeight - impBut height) / 2)) .
	separator := ImageMorph new form: (PhratchFrameMorph skinAt: #costumeSeparatorTile).
	bin addMorph: (separator position: (xOffset + 17) @ (yMargin + maxHeight + 5)).
	y := yMargin + maxHeight + 9.
	n := 0.
	images := media select: [ :item | item isImage ].
	images
		do: [ :item | 
			m := MediaItemMorph new.
			m
				phratchObj: self media: item;
				position: xOffset @ y.
			m setNumber: (n := n + 1).
			item = costume
				ifTrue: [ m highlight: true ].
			bin addMorph: m.
			y := y + m height - 1 ].
	bin submorphs size > 0
		ifTrue: [ separator width: bin firstSubmorph width - 14 ]
		ifFalse: [ separator width: 240 ].
	^ bin
]

{ #category : #blocks }
ScriptablePhratchMorph >> createBlock: block atPosition: pos onPage: page [
	"Creates a block on the given page. If the block is one that can become a watcher, then a toggle button is created as well."

	| x y changingX toggleButton yOffset frame |

	"don't create the following blocks, but keep their specs so they can be toggles using right / left arrows"

	((block respondsTo: #selector) and: [
	(#(	doRunBlockWithArgs 
		doRunBlockWithArgList
		doForkBlockWithArgs 
		doForkBlockWithArgList
		doCallBlockWithArgs 
		doCallBlockWithArgList
		functionWithArgs 
		procedureWithArgs) 
	includes: block selector)])
		ifTrue: [^pos y ].

	x := pos x.
	y := pos y.
	changingX := x.
	block canBecomeWatcher ifTrue: [
		toggleButton := self createToggleButtonFor: block.
		yOffset := (block fullBounds height - toggleButton fullBounds height) // 2.
		page addMorphBack: (toggleButton position: x@(y+yOffset)).
		changingX := x + toggleButton fullBounds width + 4].

	block fixBlockLayout; position: changingX@y.
	page addMorphBack: block.
	block canBecomeWatcher ifTrue: [
		frame := self ownerOrYourselfThatIsAPhratchFrameMorph.
		page updateWatcherButtonsForFrame: frame].

	((block respondsTo: #selector) and: [block selector = #newList:]) ifTrue: [
		block argMorphs first addArgSlot].

	^ y + block height + 3

]

{ #category : #blocks }
ScriptablePhratchMorph >> createToggleButtonFor: block [
	"Create the toggle button for each variable that could be viewed on the stage."

	| toggleButton |
	toggleButton := ToggleButton
		onForm: (PhratchFrameMorph skinAt: #watcherButtonPressed)
		offForm: (PhratchFrameMorph skinAt: #watcherButton).

	toggleButton
		target: block;
		actionSelector: #toggleWatcher;
		borderWidth: 0;
		helpText: 'View on stage' localized.

	^ toggleButton

]

{ #category : #byob }
ScriptablePhratchMorph >> customBlocks [
	^ customBlocks
]

{ #category : #byob }
ScriptablePhratchMorph >> customBlocksContaining: aBlock [
	"for error feedback"
	| def |
	customBlocks ifNil: [^Array empty].
	def := customBlocks detect: [ :each |
		each allBlocks includes: aBlock ] ifNone: [nil].
	def ifNil: [^Array empty].
	^self instancesOf: def id

]

{ #category : #blocks }
ScriptablePhratchMorph >> defaultArgsFor: blockSpec [
	"Answer the default argument for the given block specification."
	| query |
	
	query := PhratchCommandHandler from: blockSpec asArgumentWrapper on: self.
	
	^ query defaultArguments
	
]

{ #category : #media }
ScriptablePhratchMorph >> defaultImageMedia [
	"Placeholder image media."

	^ ImageMedia new
		form: (Form extent: 8@8 depth: 16) fillWhite;
		mediaName: ('costume' localized, '1');
		yourself

]

{ #category : #byob }
ScriptablePhratchMorph >> definitionFor: anId [

	| all inherited def |
	inherited := self inheritedBlocks.
	customBlocks ifNil: [customBlocks := OrderedCollection new].
	all := inherited, customBlocks.
	def := all reversed detect: [:eachDef|
		eachDef id = anId]
		ifNone: [^nil].
	(def body isBlockMorph) ifTrue: [
		def body newScriptOwnerPrivate: self].
	^ def
]

{ #category : #variables }
ScriptablePhratchMorph >> deleteAnyVariable: varName [
	"Delete the variable with the given name. It can remove a global or local variable. Do nothing if the variable doesn't exist."
	<phratchItem: 'delete variable $String$' kind: #- category: 'variables' defaultValues: #() subCategory: #a2 special: #()>
	self deleteVariable: varName.
	self ownerOrYourselfThatIsAPhratchStageMorph ifNotNil:[:e | e deleteVariable: varName.]

]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> deleteAttribute: aSymbol [

	| cat sf oi block w |
	self prototype ifNil: [
		^ self error: 'cannot delete attribute without prototype'].

	oi := self objectInterface.
	((oi at: aSymbol) at: 5) = #- ifTrue: [
		^ self error: 'undeletable attribute'].

	"special case for media"
	(#(costumes sounds) includes: aSymbol) ifFalse: [
		self perform: (oi at: aSymbol) third with: (self prototype perform: (oi at: aSymbol) second)].

	deletedAttributes ifNil: [
		deletedAttributes := Set new].
	deletedAttributes add: aSymbol.

	#costumes = aSymbol ifTrue: [
		self inheritCostumesNow].

	"update palette"

	sf := self phratchFrame.
	sf ifNil: [^ self].
	cat := (oi at: aSymbol) first.
	sf viewerPane categoryChanged: cat.

	"update watchers"

	block := self blockForSelector: ((oi at: aSymbol) second).

	block ifNil: [^ self].
	w := sf watcherForBlock: block.
	w ifNil: [^ self].
	w setCategoryColor: block color twiceLighter.
	
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> deleteAttributes: aCollection [

	"use this when duplicating a sprite"

	self undeleteAllAttributes.
	aCollection do:[:attrib |
		self deleteAttribute: attrib ]	
]

{ #category : #byob }
ScriptablePhratchMorph >> deleteDefinitionId: id [

	| stage def |
	def := self definitionFor: id.
	def isGlobal  ifFalse: [
		^ self deleteLocalDefinitionId: id].

	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ifNil: [^ self deleteLocalDefinitionId: id].

	stage sprites, {stage} do: [:obj |
		obj deleteLocalDefinitionId: id]
	
]

{ #category : #byob }
ScriptablePhratchMorph >> deleteLocalDefinitionId: id [
	| affected sf def cat |
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNil: [^self].
	sf notEditingBlock ifFalse: [^self].
	affected := self instancesOf: id.
	def := self definitionFor: id.
	def ifNil: [^ self].
	cat := def category.
	customBlocks remove: def ifAbsent: [].
	((self inheritedBlocks collect: [:b |
		b id]) includes: id) ifFalse: [
		affected do: [:eachBlock|
			eachBlock remove]].
	sf viewerPane categoryChanged: 'variables'.
	#none = cat ifFalse: [
		sf viewerPane categoryChanged: cat asString]
]

{ #category : #media }
ScriptablePhratchMorph >> deleteMedia: itemToDelete [
	"Delete the given media item."

	| oldIndex costumesBefore costumesAfter newCostume |
	oldIndex := media indexOf: itemToDelete.
	media remove: itemToDelete ifAbsent: [  ].
	itemToDelete isSound
		ifTrue: [ itemToDelete sound pause ].
	itemToDelete == costume
		ifTrue: [ 
			"select the costume just before or after the costume being deleted"
			costumesBefore := (media copyFrom: 1 to: oldIndex - 1) reject: [ :item | item isSound ].
			costumesAfter := (media copyFrom: oldIndex to: media size) reject: [ :item | item isSound ].
			costumesBefore size > 0
				ifTrue: [ newCostume := costumesBefore last ]
				ifFalse: [ 
					costumesAfter size > 0
						ifTrue: [ newCostume := costumesAfter first ]
						ifFalse: [ media addLast: (newCostume := itemToDelete) ] ].
			self lookLike: newCostume mediaName ].
	self updateMediaCategory.
	itemToDelete isSound
		ifTrue: [ 
			self undeleteAttribute: #sounds.
			self propagateSounds ]
		ifFalse: [ 
			self undeleteAttribute: #costumes.
			self propagateCostumes ]
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> deleteObject: anObject [
	"Delete the given object"
	"<phratchItem: 'delete $OSReporter$' kind: #- category: 'variables' defaultValues: #() subCategory: #a2 special: #()>"
	| oi obj att block sel rcv |
	(anObject isPhratchSpriteMorph)
		ifTrue: [ ^ self deleteSprite: anObject ].
	(anObject isCommandScriptBlockMorph)
		ifTrue: [ 
			oi := self objectInterface.
			obj := anObject receiver.
			(obj isPhratchSpriteMorph)
				ifFalse: [ ^ self error: 'cannot delete attributes of non-Sprites' ].
			block := anObject body argMorphs first.
			(block isVariableBlockMorph)
				ifTrue: [ 
					rcv := block receiver.
					rcv ifNil: [ ^ self ].
					^ rcv deleteVariable: block variable ].
			sel := block selector = #get:
				ifTrue: [ (oi at: block argMorphs first choice) second ]
				ifFalse: [ block selector ].
			att := oi keys
				detect: [ :key | (oi at: key) second = sel ]
				ifNone: [ ^ self error: 'no attribute found for selector: ' , anObject selector ].
			^ obj deleteAttribute: att ].
	self error: 'cannot delete this'
]

{ #category : #private }
ScriptablePhratchMorph >> deleteSprite [
	"Delete the sprite and all watchers that are associated with it."

	| frame sprites i presenter instances |
	frame := self ownerOrYourselfThatIsAPhratchFrameMorph. 
	frame ifNil: [
		presenter := World findA: PhratchPresenterMorph.
		presenter ifNil: [^ self delete].
		frame := presenter frame].

	frame deleteWatchersForSprite: self.
	instances := self instances.

	frame workPane updateSpritesList.
	sprites := frame workPane sprites.
	i := sprites indexOf: self.  "remember my index"
	sprites remove: self ifAbsent: [].

	self delete.
	instances do: [:each |
		each prototype: nil].

	frame libraryPane fixLayout.

	"delete my thumbnail, and re-focus on the thumbnail right after me or the stage if there are no sprites"
	i > sprites size ifTrue: [i := i - 1].
	i < 1 
		ifTrue: [frame view: frame workPane tab: 'Scripts' category: 'motion'] 
		ifFalse: [frame view: (sprites at: i) tab: 'Scripts' category: 'motion'].	

]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> deleteSprite: aSprite [
	aSprite deleteSpriteQuickly.

	"now the deleted sprite has to be removed from all variables
	and lists - not sure how to accomplish this"
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> deleteSpriteObj: anObject [
	"Delete the given sprite"
	<phratchItem: 'delete $Sprite$' kind: #- category: 'control' defaultValues: #() subCategory: #self special: #()>
	self deleteObject: anObject
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> deleteSpriteQuickly [
	"Delete the sprite and all watchers that are associated with it."

	| frame sprites presenter instances |
	frame := self ownerOrYourselfThatIsAPhratchFrameMorph. 
	frame ifNil: [
		presenter := World findA: PhratchPresenterMorph.
		presenter ifNil: [^ self delete].
		frame := presenter frame].

	frame deleteWatchersForSprite: self.
	instances := self instances.

	frame workPane updateSpritesList.
	sprites := frame workPane sprites.
	sprites remove: self ifAbsent: [].

	self delete.
	instances do: [:each |
		each undeleteAllAttributes.
		each undeleteAllVariables.
		each prototype: nil].

	frame libraryPane fixLayout.

	"delete my thumbnail, and re-focus on the thumbnail right after me or the stage if there are no sprites"

	frame view: frame workPane tab: 'Scripts' category: 'motion'
"
	i > sprites size ifTrue: [i := i - 1].
	i < 1 
		ifTrue: [frame view: frame workPane tab: 'Scripts' category: 'motion'] 
		ifFalse: [frame view: (sprites at: i) tab: 'Scripts' category: 'motion'].	
"
]

{ #category : #variables }
ScriptablePhratchMorph >> deleteVariable [
	"Ask the user which user variable to delete, then remove it."

	| sFrame stage menu |
	sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sFrame ifNil: [^ self].

	stage := sFrame workPane.
	(stage varNames isEmpty) & (self varNames isEmpty)
		ifTrue: [^ self inform: 'No variables.' localized].

	menu := MenuMorph new defaultTarget: self.
	stage varNames do: [:v | menu add: v target: stage selector: #deleteVariable: argument: v].
	self = stage ifFalse: [
		stage varNames isEmpty ifFalse: [menu addLine].
		self varNames do: [:v | menu add: v target: self selector: #deleteVariable: argument: v]].
	menu invokeModal.

	sFrame viewerPane categoryChanged: 'variables'.

]

{ #category : #variables }
ScriptablePhratchMorph >> deleteVariable: varName [
	"Delete the variable with the given name. Do nothing if the variable doesn't exist."
	| frame w |
	frame := self phratchFrame.
	frame ifNotNil: [
		(self prototype notNil and: [self prototype varNames includes: varName]) ifFalse: [
			frame deleteWatchersForVar: varName ofSprite: self]].
	vars removeKey: varName asString ifAbsent: [^ self].
	frame viewerPane categoryChanged: 'variables'.
	w := frame watcherForBlock: (VariableBlockMorph new receiver: self; commandSpec: varName; yourself).
	w ifNotNil: [w setCategoryColor: (PhratchCategory blockColorFor: 'variables') twiceLighter].
	self isClone: false.

]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> deletedAttributes [
	^ deletedAttributes ifNil: [ 
		deletedAttributes := Set new]
]

{ #category : #variables }
ScriptablePhratchMorph >> desparatelyGetVar: varName from: aVarBlockMorph [

	| anotherReceiver |
	anotherReceiver := aVarBlockMorph phratchObject.
	anotherReceiver ifNil: [^ 0].
	(anotherReceiver varNames includes: varName)	ifFalse: [
		anotherReceiver := anotherReceiver ownerOrYourselfThatIsAPhratchStageMorph.
		anotherReceiver ifNil: [^ 0].
		(anotherReceiver varNames includes: varName) ifFalse: [
			^ 0]].
	aVarBlockMorph receiver: anotherReceiver.
	^ anotherReceiver getVar: varName
		
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doAnswer [
	"Answer the given result."
	<phratchItem: 'report $String$' kind: #SpecialBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #byob }
ScriptablePhratchMorph >> doBroadcastAndWait [
	"send a broadcast message ans wait for all receivers finish their work."
	<phratchItem: 'broadcast $Event$ and wait' kind: #SpecialBlockMorph category: 'control' defaultValues: #() subCategory: #broadcast special: #()>
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doCallBlockWithArgList [
	"Call the given block with a list of args."
	<phratchItem: 'call $OSReporter$ $Input$ $SAList$' kind: #MultiArgReporterBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doCallBlockWithArgs [
	"Call the given block with the given args."
	<phratchItem: 'call $OSReporter$ $Input$ $String$' kind: #MultiArgReporterBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #byob }
ScriptablePhratchMorph >> doForever [
	"Forever loop"
	<phratchItem: 'forever' kind: #CBlockMorph category: 'control' defaultValues: #() subCategory: #loop special: #()>
]

{ #category : #byob }
ScriptablePhratchMorph >> doForeverIf [
	"Forever loop if the given condition is true"
	<phratchItem: 'forever if $Boolean$' kind: #CBlockMorph category: 'control' defaultValues: #() subCategory: #loop special: #()>
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doFork [
	"Launch the given block in another thread."
	<phratchItem: 'launch $CSlot$' kind: #MultiArgCommandBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doForkBlockWithArgList [
	"Launch the given block in another thread with the given list of args."
	<phratchItem: 'launch $CSlot$ $Input$ $SAList$' kind: #MultiArgCommandBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doForkBlockWithArgs [
	"Launch the given block in another thread with the given args."
	<phratchItem: 'launch $CSlot$ $Input$ $String$' kind: #MultiArgCommandBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doIf [
	"If the given arg is true, execute the following blocks"
	<phratchItem: 'if $Boolean$' kind: #CBlockMorph category: 'control' defaultValues: #() subCategory: #if special: #()>

	
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doIfElse [
	"If the given arg is true, execute the first list of blocks, else the second"
	<phratchItem: 'if $Boolean$' kind: #IfElseBlockMorph category: 'control' defaultValues: #() subCategory: #if special: #()>

]

{ #category : #byob }
ScriptablePhratchMorph >> doRepeat [
	"Repeat the given number times the included blocks"
	<phratchItem: 'repeat $Number$ times' kind: #CBlockMorph category: 'control' defaultValues: #(10) subCategory: #loop special: #()>
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doReport [
	"Call the given block"
	<phratchItem: 'call $OSReporter$' kind: #MultiArgReporterBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #byob }
ScriptablePhratchMorph >> doReturn [
	"Stop the current script"
	<phratchItem: 'stop script' kind: #SpecialBlockMorph category: 'control' defaultValues: #() subCategory: #loop special: #()>
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doRun [
	"Run the given block"
	<phratchItem: 'run $CSlot$' kind: #MultiArgCommandBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doRunBlockWithArgList [
	"Run the given block with the given list of args."
	<phratchItem: 'run $CSlot$ $Input$ $SAList$' kind: #MultiArgCommandBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> doRunBlockWithArgs [
	"Run the given block with the given args."
	<phratchItem: 'run $CSlot$ $Input$ $String$' kind: #MultiArgCommandBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> doStopBlock [
	"Stop the current block!"
	<phratchItem: 'stop block' kind: #SpecialBlockMorph category: 'control' defaultValues: #() subCategory: #startstop special: #()>
	
]

{ #category : #byob }
ScriptablePhratchMorph >> doUntil [
	"Repeat until the given condition"
	<phratchItem: 'repeat until $Boolean$' kind: #CBlockMorph category: 'control' defaultValues: #(10) subCategory: #loop special: #()>
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> doWaitUntil [
	"Do nothing; just wait until the given condition."
	<phratchItem: 'wait until $Boolean$' kind: #SpecialBlockMorph category: 'control' defaultValues: #() subCategory: #time special: #()>


]

{ #category : #'event handling' }
ScriptablePhratchMorph >> doubleClick: evt [
	"Show my viewer and script editor."
	
	| hand |
	hand := self world activeHand.
	hand toolType ifNotNil: [
		^ self handleTool: hand toolType hand: hand].

	self viewBlocksAndScripts.

]

{ #category : #media }
ScriptablePhratchMorph >> drawNewCostume [

	| oldCostumeName newName newImage |
	oldCostumeName := costume mediaName.
	newImage := ImageMedia new form: (Form extent:  4@4 depth: 16).
	newName := (self unusedMediaNameFromBaseName: self defaultImageMedia mediaName).
 	newImage mediaName: newName.
	media addLast: newImage.
	self updateMediaCategory.
	self lookLike: newImage mediaName.
	self editDrawingOldCostumeName: oldCostumeName deleteOnCancel: false.
	
	self undeleteAttribute: #costumes.
	
	self propagateCostumes


]

{ #category : #scripts }
ScriptablePhratchMorph >> duplicate [

	| newSprite |
	newSprite := self duplicateNoAttach.
	self world activeHand attachMorph: newSprite.

	"((s := self ownerOrYourselfThatIsAPhratchStageMorph) notNil and:"
	" [s isQuarterSize]) ifTrue: [
		self world activeHand drawHalfSize: true]."

	^ newSprite

]

{ #category : #media }
ScriptablePhratchMorph >> duplicateMedia: itemToDuplicate [
	"Duplicate the given media item."

	| dup |
	itemToDuplicate isSound ifTrue: [itemToDuplicate pausePlaying].
	dup := itemToDuplicate copy.
	dup mediaName: (self unusedMediaNameFromBaseName: itemToDuplicate mediaName).
	media addLast: dup.
	self updateMediaCategory.

	itemToDuplicate isSound 
		ifTrue: [
			self undeleteAttribute: #sounds.
			self propagateSounds]
		ifFalse: [
			self undeleteAttribute: #costumes.
			self propagateCostumes]
]

{ #category : #'right button menu' }
ScriptablePhratchMorph >> duplicateNoAttach [
	"Duplicate this sprite, but do not attach to the hand."

	| newSprite frame |
	newSprite := self fullCopy.
	newSprite undeleteAllAttributes.
	newSprite unhinge; unhingeAll; initializeNodes.
	newSprite position: (newSprite position + 20).
	frame := self ownerOrYourselfThatIsAPhratchFrameMorph.
	frame ifNotNil: [
		frame workPane addMorphFront: newSprite.
		frame workPane sprites addLast: newSprite].
	^ newSprite

]

{ #category : #'right button menu' }
ScriptablePhratchMorph >> editDrawing [
	"Edit my current form with the paint editor."

	self editDrawingOldCostumeName: nil deleteOnCancel: false.

]

{ #category : #'right button menu' }
ScriptablePhratchMorph >> editDrawingOldCostumeName: oldCostumeName deleteOnCancel: aBoolean [
	"Edit my original form with the paint editor."

	| sFrame paintEditor |
	costume isMovie ifTrue: [^ PhratchError error: 'beep'.].
	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph)
		ifNotNil: [
			sFrame paintingInProgress ifTrue: [^ PhratchError error: 'beep'.].
			sFrame stopAll.
			sFrame paintingInProgress: true].

	paintEditor := PaintFrame new.
	paintEditor
		withStartingObject: self;
		phratchFrame: sFrame;
		oldCostumeName: oldCostumeName deleteOnCancel: aBoolean.

	oldCostumeName ifNotNil: [
		"When an oldCostumeName is supplied, it means I'm making a new drawing. Clear the initial rotation center."
		paintEditor clearRotationCenter].

	(paintEditor isDialogBoxMorph)
		ifTrue: [paintEditor getUserResponse]
		ifFalse: [
			World addMorphFront: paintEditor.
			World startSteppingSubmorphsOf: paintEditor].

]

{ #category : #byob }
ScriptablePhratchMorph >> editScriptId: id [
	|sf def|

	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
"	sf ifNil: [^self]."
	def := self definitionFor: id.
"	def ifNil: [^self]."
	sf editBlockDefinition: def for: self
]

{ #category : #byob }
ScriptablePhratchMorph >> editSpecId: id [
	"let the user change the category (color) of a custom block"

	| stage ans def sf bd oldCat inst newType |
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNil: [ ^ self ].
	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	def := self definitionFor: id.
	newType := def type.
	BlockDialog isOpen
		ifTrue: [ ^ self ].
	bd := BlockDialog new.
	bd
		title: '?' localized;
		withButtonsForYes: false
			no: false
			okay: true
			cancel: true;
		message: 'Custom block category';
		setUserSpec: def userSpec;
		setCategory: def category;
		setType: def type;
		updateTypeSelection.
	inst := self instancesOf: id.
	def isGlobal
		ifTrue: [ 
			inst := OrderedCollection new.
			stage isNil
				ifFalse: [ stage sprites , {stage} do: [ :obj | inst addAll: (obj instancesOf: id) ] ] ].
	inst isEmpty
		ifTrue: [ bd disableAllButCategoryAndShape ]
		ifFalse: [ bd disableAllButCategory ].
	bd updateInitialSettings.
	ans := bd getUserResponse.
	ans = #cancelled
		ifTrue: [ ^ self ].
	ans first isEmpty
		ifTrue: [ ^ self ].
	((self existsBlockId: (CustomBlockDefinition idFromSpec: ans first)) and: [ def userSpec ~= ans first ])
		ifTrue: [ ^ DialogBoxMorph warn: 'a custom block with this label already exists' localized ].
	(def varNames includesAnyOf: (def parameterNamesInSpec: ans first))
		ifTrue: [ ^ DialogBoxMorph warn: 'a block variable with the same name as a parameter already exists' ].
	ans = def userSpec
		ifTrue: [ ^ self ].
	ans isEmpty
		ifTrue: [ ^ self ].
	(self existsBlockId: (CustomBlockDefinition idFromSpec: ans))
		ifTrue: [ ^ DialogBoxMorph warn: 'a custom block with this label already exists' ].
	(def varNames includesAnyOf: (def parameterNamesInSpec: ans first))
		ifTrue: [ ^ DialogBoxMorph warn: 'a block variable with the same name as a parameter already exists' ].
	inst isEmpty
		ifTrue: [ 
			newType := (ans at: 2)
				ifTrue: [ 
					(ans at: 3)
						ifTrue: [ #boolean ]
						ifFalse: [ #any ] ]
				ifFalse: [ #none ] ].
	def type = newType
		ifFalse: [ def type: newType ].
	oldCat := def category.
	def
		category:
			(ans fourth = #other
				ifTrue: [ #none ]
				ifFalse: [ ans fourth ]).
	#none = oldCat
		ifFalse: [ sf viewerPane categoryChanged: oldCat asString ].
	def isGlobal
		ifFalse: [ ^ self updateLocalId: id withSpec: ans first ].
	"stage ifNil: [ ^ self updateId: id withSpec: ans first ]."
	stage sprites , {stage}
		do: [ :obj | 
			obj
				updateCustomBlockDefinitionId: id with: def;
				updateLocalId: id withSpec: ans first ]
]

{ #category : #media }
ScriptablePhratchMorph >> editedForm: aForm textBox: aMultilineTextMorph [

	| newImage |
	(costume isKindOf: ImageMedia) ifFalse: [
		newImage := ImageMedia new
			form: aForm;
			mediaName: (self unusedMediaNameFromBaseName: costume mediaName);
		yourself.
		media addLast: newImage.
		self lookLike: newImage mediaName].

	costume form: aForm.  "replace the current costume"
	costume textBox: aMultilineTextMorph.
	self lookLike: costume mediaName.
	self viewBlocksAndScripts.
	self updateMediaCategory.

	self undeleteAttribute: #costumes.
	self propagateCostumes


]

{ #category : #byob }
ScriptablePhratchMorph >> ensureCustomBlockExists: aBlockDef [

	| def bod |
 	aBlockDef ifNil: [^ self].
	(self definitionFor: aBlockDef id) ifNil: [
		def := aBlockDef "deepCopy" veryDeepCopy.
		customBlocks add: def.
		bod := aBlockDef body.
		bod ifNotNil: [def body: (bod fullCopy newScriptOwner: self) ]]
]

{ #category : #byob }
ScriptablePhratchMorph >> ensureCustomBlockExists: aBlockDef global: bool [

	| stage |

	stage := self ownerOrYourselfThatIsAPhratchStageMorph.

	(bool not or: [stage isNil]) ifTrue: [
		^ self ensureCustomBlockExists: aBlockDef].

	stage sprites, {stage} do: [:obj |
		obj ensureCustomBlockExists: aBlockDef]
	
]

{ #category : #variables }
ScriptablePhratchMorph >> ensureListExists: listName [
	"If a list with the given name is not visible to this object, make one."

	| stage |

	listName = '' ifTrue: [^ self].

	(lists includesKey: listName) ifTrue: [^ self].
	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [
		(stage listVarNames includes: listName) ifTrue: [^ self]].
	(self prototype notNil and: [self prototype listVarNames includes: listName])
		ifTrue: [^ self].


	"list not found; create it"
	lists at: listName put: (PhratchListMorph new listName: listName target: self).


]

{ #category : #byob }
ScriptablePhratchMorph >> ensureOwnBlockExists: aBlockDef [

	| def bod defId |

 	aBlockDef ifNil: [^ self].
	defId := aBlockDef id.
	customBlocks ifNil: [customBlocks := OrderedCollection new].
	customBlocks detect: [:eachDef|
		eachDef id = defId]
		ifNone: [
			def := aBlockDef deepCopy.
			bod := aBlockDef body.
			bod ifNotNil: [def body: (bod fullCopy newScriptOwner: self)].
			customBlocks add: def]

]

{ #category : #variables }
ScriptablePhratchMorph >> ensureVariableExists: varName [
	"Make sure that the variable with the given name is visible to this object. Do nothing if the variable already exists."

	| stage vn |
	(varName isArray)
		ifTrue: [^ self].
	(varName isCommandBlockMorph)
		ifTrue: [^ self].

	vn := varName asString.	
	vn = '' ifTrue: [^ self].

	(vars includesKey: vn) ifTrue: [^ self].
	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [
		(stage varNames includes: vn) ifTrue: [^ self]].
	(self prototype notNil and: [self prototype varNames includes: vn])
		ifTrue: [^ self].

	"variable not found; create it"
	vars at: vn asString put: 0.

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> eventReceived: event [
	"Start all non-running stacks with an EventHat matching the given events and answer a collection of the new processes. If a process is already running for a given stack, don't start a new one."

	| targetScripts newProcs |
	targetScripts := #().
	event name = 'Phratch-KeyPressedEvent'
		ifTrue: [ targetScripts := self scripts select: [ :s | s class == KeyEventHatMorph and: [ s respondsToKeyEvent: event argument ] ] ]
		ifFalse: [ 
			event name = 'Phratch-MouseClickEvent'
				ifTrue: [ 
					self isHidden
						ifFalse: [ targetScripts := self scripts select: [ :s | s class == MouseClickEventHatMorph ] ] ]
				ifFalse: [ 
					targetScripts := event name = 'Phratch-CreationEvent'
						ifTrue: [ self scripts select: [ :s | s class == CreationEventHatMorph ] ]
						ifFalse: [ self scripts select: [ :s | (s class == EventHatMorph or: [s class == StartEventHatMorph]) and: [ s eventName caseInsensitiveEqual: event name ] ] ] ] ].
	newProcs := targetScripts asArray collect: [ :script | script startForEvent: event ].
	^ newProcs select: [ :p | p notNil ]
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> eventReceivedNamed: eventName [
	"Answer true if the given event is received."
	<phratchItem: '$Event$ received?' kind: #BooleanWatcherBlockMorph category: 'control' defaultValues: #() subCategory: #broadcast special: #()>
	| targetScripts procs |
	self isSprite ifTrue: [^ (self ownerThatIsAPhratchStageMorph) eventReceivedNamed: eventName].
	targetScripts := self scripts select: [:s |
		((s class == EventHatMorph) or: [s class == StartEventHatMorph]) and: [s eventName caseInsensitiveEqual: eventName]].
	targetScripts := targetScripts asOrderedCollection.
	self submorphsDo: [:m |
		(m isScriptablePhratchMorph) ifTrue: [
			(m scripts select: [:s |
				(s class == EventHatMorph) and:
				[s eventName caseInsensitiveEqual: eventName]]) do: [:script | targetScripts := targetScripts copyWith: script]]].

	procs := targetScripts select: [:s |
		s phratchProc notNil].
	^ procs size > 0.
]

{ #category : #byob }
ScriptablePhratchMorph >> existsBlockId: id [

	customBlocks ifNil: [customBlocks := OrderedCollection new].
	customBlocks detect: [:def|
		def id = id ] ifNone: [^false].
	^true
]

{ #category : #byob }
ScriptablePhratchMorph >> existsBlockId: id global: bool [
	| stage |
	bool
		ifTrue: [ ^ self existsBlockId: id ].
	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ifNil: [ ^ self existsBlockId: id ].
	^ stage sprites , {stage} anySatisfy: [ :obj | obj existsBlockId: id ]
]

{ #category : #'block API' }
ScriptablePhratchMorph >> exitPhratch [
	"WARNING: this block closes Phratch !"
	<phratchItem: 'quit Phratch' kind: #- category: 'control' defaultValues: #() subCategory: #project special: #()>
    Smalltalk snapshot: false andQuit: true
]

{ #category : #'right button menu' }
ScriptablePhratchMorph >> exportObject [

	| fName dir f objToExport |

	fName := PhratchFileChooserDialog
		chooseNewFileDefault: objName
		title: 'Export Sprite'
		type: #sprite.
	fName = #cancelled ifTrue: [^ self].
	fName size = 0 ifTrue: [^ self].
"	(fName endsWith: '.sprite') ifFalse: [fName := fName, '.sprite']."
	(fName endsWith: '.phsp') ifFalse: [fName := fName, '.phsp'].
	dir := fName asFileReference parent.
	fName := fName asFileReference basename.  "ignore path, if any; save in default directory"

	
	(dir / fName) exists ifTrue: [
		(DialogBoxMorph ask: 'Overwrite existing ', fName, '?') ifFalse: [^ self].
		(dir / fName) delete].

	f := nil.
	[	f := (StandardFileStream newFileNamed: (dir / fName)) binary.
		objToExport := self copyForExport.
		objToExport objName: fName.

		objToExport firstSubmorph allSubsprites do: [:eachSub |
			eachSub owner ifNil: [objToExport addMorphBack: eachSub ]].
		FuelObjStream new storeObj: objToExport on: f showProgress: false.
		f close.
		FilePluginPrims new setMacFileNamed: (dir / fName) fullName type: 'phsp' creator: 'PHRA'.

	] ifError: [
		f ifNotNil: [f close].
		PhratchError errorWithDialog: 'Could not write file'].


]

{ #category : #'block API' }
ScriptablePhratchMorph >> factorial: t1 [ 
	"Compute the factorial of the given number"
	<phratchItem: 'factorial of $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #() subCategory: #a1 special: #()>
    | answer t1store |
    t1 isInf ifTrue:[^0].
    t1 isNaN ifTrue:[^0].
    answer := 1.
    t1store := t1.
    t1 = 0 ifTrue: [^ 1].
    t1 < 0 ifTrue: [^ 0].
    t1 isInf ifTrue: [^ 0].
    t1 isNaN ifTrue: [^ 0].
    [t1store > 1]
        whileTrue: 
            [answer := answer * t1store.
            t1store := t1store - 1].
    ^ answer
]

{ #category : #accessing }
ScriptablePhratchMorph >> filteredForm [
	
	filterPack ifNil: [^ self rotatedForm].

	filterPack filtersActive ifTrue: [  "filter parameters have changed; apply filters"
		[filterPack applyFiltersTo: self rotatedForm]
						ifError: [PhratchError error:  'There is a problem with FilterPack'. filterPack := nil. ^ self rotatedForm]].

	^ filterPack resultForm

]

{ #category : #accessing }
ScriptablePhratchMorph >> form [
	"Answer my current costume form, without filtering, rotation, or scaling."

	^ self costumeForm

]

{ #category : #accessing }
ScriptablePhratchMorph >> form: aForm [

	costume := (ImageMedia new form: aForm).
	costume mediaName: (self unusedMediaNameFromBaseName: 'costume').
	media addLast: costume.
	self costumeChanged.
	self updateMediaCategory.

	self undeleteAttribute: #costumes.
	self propagateCostumes

]

{ #category : #'blocks API' }
ScriptablePhratchMorph >> function [
	"Return the given block without executing it"
	<phratchItem: 'the $SAReporter$ block' kind: #ReporterScriptBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>
]

{ #category : #'blocks API' }
ScriptablePhratchMorph >> functionWithArgs [
	"Return the given block with args without executing it"
	<phratchItem: 'the $SAReporter$ block. Input names: $String$' kind: #ReporterScriptBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> get: anObject [
	"Return the value of the given attribute"
	<phratchItem: 'attribute $Attributes$' kind: #ReporterBlockMorph category: 'sensing' defaultValues: #() subCategory: #a3 special: #()>
	| oi sel obj att block |

	anObject = #null
		ifTrue: [^nil].

	oi := self objectInterface.

	(anObject isSymbol) ifTrue: [
		sel := oi at: anObject ifAbsent: [^ self error: 'unknown attribute: ', anObject asString ].
		sel second = #- ifTrue: [
			^ self error: 'cannot read this attribute'].
		^ self perform: sel second ].
		
	(anObject isCommandScriptBlockMorph) ifTrue: [
		obj := anObject receiver.
		(obj isScriptablePhratchMorph) ifFalse: [
			^ self error: 'cannot get attributes of non-Sprites/Stage'].
		block := anObject body argMorphs first.
		att := oi keys detect: [:key |
			(oi at: key) second  = block selector] ifNone: [
				^ self error: 'no attribute found for selector: ', anObject selector].
		^ obj get: att ].

	^ anObject
]

{ #category : #byob }
ScriptablePhratchMorph >> getFalse [
	"Return the boolean False"
	<phratchItem: 'false' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a4 special: #()>
	^false
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> getSpawnOf: anObject [
	^ anObject spawn
]

{ #category : #byob }
ScriptablePhratchMorph >> getTrue [
	"Return the boolean True"
	<phratchItem: 'true' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a4 special: #()>
	^true
]

{ #category : #variables }
ScriptablePhratchMorph >> getVar: varName [
	"Answer the value of the given user variable of this object, or 0 if the variable has been deleted."

	| stage |
	(vars includesKey: varName)
		ifFalse: [ stage := (self ownerOrYourselfThatIsAPhratchStageMorph).
			stage ifNotNil: [	^ stage vars at: varName asString ifAbsent: [
				(self prototype notNil and: [self prototype varNames includes: varName])
					ifTrue:[^self prototype getVar: varName]
					ifFalse: [^self phratchObject getVar: varName]]].
			(self prototype notNil and: [self prototype varNames includes: varName])
					ifTrue:[^self prototype getVar: varName]
					ifFalse: [^self phratchObject getVar: varName]].
	^ vars at: varName asString ifAbsent: [0]

]

{ #category : #variables }
ScriptablePhratchMorph >> getVar: varName block: aVariableBlockMorph [
	"Answer the value of the given user variable of this object, or 0 if the variable has been deleted."

	(vars includesKey: varName)
		ifFalse: [ ^ (self ownerOrYourselfThatIsAPhratchStageMorph) vars at: varName asString ifAbsent: [
			(self prototype notNil and: [self prototype varNames includes: varName])
				ifTrue:[self prototype getVar: varName]
				ifFalse: [^ self desparatelyGetVar: varName from: aVariableBlockMorph]]].
	^ vars at: varName asString ifAbsent: [0]

]

{ #category : #'BYOB OOP message passing' }
ScriptablePhratchMorph >> getVarOrListNamed: varName [
	"Get the variable or list with the given name"
	<phratchItem: 'variable or list named $String$' kind: #ReporterBlockMorph category: 'variables' defaultValues: #() subCategory: #a3 special: #()>
	| value |
	"first let's try to find a variable"
	value := (vars includesKey: varName)
		ifFalse: [ 
			(self ownerOrYourselfThatIsAPhratchStageMorph) vars
				at: varName asString
				ifAbsent: [ 
					(self prototype notNil and: [ self prototype varNames includes: varName ])
						ifTrue: [ self prototype getVar: varName ]
						ifFalse: [ nil ] ] ]
		ifTrue: [ vars at: varName asString ifAbsent: [ nil ] ].	"if none is found check for a named list"
	value
		ifNil: [ 
			value := self
				listNamed: varName
				ifNone: [ 
					self error: 'no such variable or list'.
					nil ] ].
	^ value
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> graphicEffectNames [
	"Answer a collection of graphic effect names."

	^ #(
		'color'
		'fisheye'
		'whirl'
		'pixelate'
		'mosaic'
		'brightness'
		'ghost')

]

{ #category : #'event handling' }
ScriptablePhratchMorph >> handleTool: toolName hand: hand [

	| scaleFactor |
	toolName = 'CopyTool' ifTrue: [
		Sensor shiftPressed ifFalse: [hand toolType: nil].
		(self isPhratchStageMorph) ifFalse: [
			^ self duplicate]].

	toolName = 'CutTool' ifTrue: [
		Sensor shiftPressed ifFalse: [hand toolType: nil].
		(self isPhratchStageMorph) ifFalse: [
			^ self undoableDeleteSprite]].

	"exit now if I am not scalable"
	(self respondsTo: #multiplySizeBy:) ifFalse: [
		PhratchError error: 'beep'.
		hand toolType: nil.
		^ self].

	scaleFactor := hand lastEvent shiftPressed ifTrue: [1.2] ifFalse: [1.03].
	toolName = 'ZoomInTool' ifTrue: [^ self multiplySizeBy: scaleFactor].
	toolName = 'ZoomOutTool' ifTrue: [^ self multiplySizeBy: 1.0 / scaleFactor].

]

{ #category : #media }
ScriptablePhratchMorph >> handlesDropShadowInHand [
	^ true
]

{ #category : #'event handling' }
ScriptablePhratchMorph >> handlesMouseDown: evt [

	^ self isVisible

]

{ #category : #variables }
ScriptablePhratchMorph >> hideVariable: varName [
	"Hide the watcher(s) for the given variable. If the receiver is a sprite and both it and and the stage have the given variable, hide both. Do nothing if the variable does not exist or is already hidden."
	<phratchItem: 'hide variable $Variable$' kind: #- category: 'variables' defaultValues: #() subCategory: #a2 special: #()>
	| stage |
	self showOrHideVariable: varName show: false.

	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ~= self ifTrue: [stage showOrHideVariable: varName show: false].


]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> if: aCondition then: trueString else: falseString [
"Answer the first string if the given condition is true, otherwise answer the second."
	<phratchItem: 'if $Boolean$ then $String$ else $String$' kind: #ReporterBlockMorph category: 'control' defaultValues: #() subCategory: #if special: #()>
	aCondition
		ifTrue: [^ trueString].
	^ falseString
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> ifB: aCondition then: trueString else: falseString [
"Answer the first boolean if the given condition is true, otherwise answer the second."
	<phratchItem: 'if $Boolean$ then $Boolean$ else $Boolean$' kind: #BooleanBlockMorph category: 'control' defaultValues: #() subCategory: #if special: #()>
	aCondition
		ifTrue: [^ trueString = true].
	^ falseString
]

{ #category : #accessing }
ScriptablePhratchMorph >> imageForm [
	"Answer a Form showing myself for the purpose of generating a thumbnail."

	^ self filteredForm copy offset: 0@0

]

{ #category : #media }
ScriptablePhratchMorph >> importImage [
	"Import a new image from a file and add it to my media (concatenating the name if it is greater than 16 characters long). If the file is an animated gif, import all frames of the gif as separate costumes."

	| title result el fList isFirst newName type |
	(self isPhratchStageMorph)
		ifTrue: [type := #background. title := 'Import Background']
		ifFalse: [type := #costume. title := 'Import Costume'].
	result := PhratchFileChooserDialog
		chooseImageFileType: type
		title: title.
	result = #cancelled ifTrue: [^ self].

	fList := OrderedCollection new.

	[fList addLast: (Form fromFileNamed: result)] ifError: [^ self].

	isFirst := true.
	fList do: [:f |
		el := ImageMedia new form: (PhratchFrameMorph scaledFormForPaintEditor: f).
		newName := self mediaNameFromFileName: result default: 'costume'.
		el mediaName: (self unusedMediaNameFromBaseName: (String withAll: newName)).
		media addLast: el.
		isFirst ifTrue: [isFirst := false. self lookLike: el mediaName.]].

	self updateMediaCategory.
	self undeleteAttribute: #costumes.
	self propagateCostumes

]

{ #category : #media }
ScriptablePhratchMorph >> importMedia: fileName [
	"Import a new image from a file and add it to my media."

	|  extensionLoc elList baseName fList isFirst |
	extensionLoc := ( fileName) extension asLowercase.

	elList := OrderedCollection new.

	(Smalltalk at: #PhratchCategorySound ifPresent:[
		(#(aif aiff wav mp3) includes: extensionLoc) ifTrue: [
			baseName := self mediaNameFromFileName: fileName default: 'sound'.
			[elList addLast: ((Smalltalk at: #SoundMedia) new loadFile: fileName)] ifError: [^ self]].
	]).
	(#(jpg jpeg gif bmp png) includes: extensionLoc) ifTrue: [
		baseName := self
			mediaNameFromFileName: fileName
			default: self defaultImageMedia mediaName.
		fList := OrderedCollection new.
		"extensionLoc = 'gif' 
			ifTrue: 
				[[fList := (GIFReadWriter new on: (FileStream oldFileNamed: fileName)) nextImageSet] ifError: [^ self]]
			ifFalse: 
				["[fList addLast: (Form fromFileNamed: fileName)] ifError: [^ self]"]".
		fList do: [:f | 
			elList addLast: (ImageMedia new form: (PhratchFrameMorph scaledFormForPaintEditor: f))]].

	elList isEmpty ifTrue: [^ self].  "unknown file type; ignore"

	isFirst := true.
	elList do: [:el | 
		el mediaName: (self unusedMediaNameFromBaseName: baseName).
		media addLast: el.
		isFirst ifTrue: [
			isFirst := false. 
			el isSound 
				ifTrue: [
					self undeleteAttribute: #sounds.
					self propagateSounds
					]
				ifFalse: [
					self lookLike: el mediaName.
					self undeleteAttribute: #costumes.
					self propagateCostumes]]].
	
	self updateMediaCategory.

]

{ #category : #accessing }
ScriptablePhratchMorph >> inPresentationMode [

	^ (self ownerOrYourselfThatIsAOffscreenWorldMorph) notNil

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> indexOf: subString startingAt: aNumber in: aString [
	"Return the index of the given value in the given list starting at a given index"
	<phratchItem: 'index of $String$ starting at $Number$ in $String$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('o' 6 'hello world') subCategory: #a6 special: #()>
    ^ aString asString findString: subString startingAt: aNumber
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> inheritCostumesNow [
	| att idx |
	att := #costumes.
	self prototype ifNil: [ ^ self ].
	(self deletedAttributes includes: att)
		ifFalse: [ ^ self ].
	idx := self costumeIndex.
	media := media select: [ :item | item isSound ].
	self prototype media
		do: [ :item | 
			item isSound
				ifFalse: [ media addLast: item copy ] ].
	self passiveLookLike: idx.
	self updateMediaCategory.
	self propagateCostumes
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> inheritSoundsNow [

	| att |
	att := #sounds.
	self prototype ifNil: [^ self].
	(self deletedAttributes includes: att) ifFalse: [^ self].

	media := media reject: [:item |
		item isSound].

	self prototype media do: [:item |
		item isSound ifTrue: [
			media addLast: item copy]].

	self updateMediaCategory.

	self propagateSounds
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> inheritedBlockIds [

	| ownIds inheritedIds |
	self prototype ifNil: [^ #()].
	ownIds := self blockIds.
	inheritedIds := (self prototype localBlocks collect: [:each | 
		each id ]) reject: [:id |
			ownIds includes: id].
	^ inheritedIds
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> inheritedBlocks [

	^ self inheritedBlockIds collect: [:id | 
		self prototype definitionFor: id ]
]

{ #category : #initialization }
ScriptablePhratchMorph >> initialize [

	super initialize.
	objName := self nextInstanceName.
	vars := Dictionary new.
	lists := Dictionary new.
	colors:= Dictionary new.
	blocksBin := PhratchScriptsMorph new.
	isClone := false.
	costume := self defaultImageMedia.
	media := OrderedCollection new.
	costumeChangeMSecs := 0.
	visibility := 100.
	volume := 100.
	sceneStates := Dictionary new.
	phratchModel := self.

]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> initializeVarsAndLists [
	"used when spawning (cloning)"

	vars := Dictionary new.
	lists := Dictionary new
]

{ #category : #media }
ScriptablePhratchMorph >> insertMedia: aPhratchMedia before: targetOrNil [
	"Shuffle my media list so that the given media item comes immediately before the target media item, or at the end of the list if targetPhratchMedia is nil. Do nothing if the given item is the same as the target item."

	| mediaItem |
	aPhratchMedia == targetOrNil ifTrue: [^ self].

	mediaItem := aPhratchMedia.
	(media includes: aPhratchMedia) ifFalse: [
		"dropping an undeleted media item"
		mediaItem := mediaItem copy.
		mediaItem mediaName: (self unusedMediaNameFromBaseName: mediaItem mediaName).
		media addLast: mediaItem].

	media remove: mediaItem.
	targetOrNil
		ifNil: [media addLast: mediaItem]
		ifNotNil: [media add: mediaItem before: targetOrNil].
	self updateMediaCategory.

	aPhratchMedia isSound 
		ifTrue: [
			self undeleteAttribute: #sounds.
			self propagateSounds]
		ifFalse: [
			self undeleteAttribute: #costumes.
			self propagateCostumes]

]

{ #category : #'debug and other' }
ScriptablePhratchMorph >> inspect: anObject [
	anObject inspect
]

{ #category : #byob }
ScriptablePhratchMorph >> installGlobalBlocks [

	| stage |

	stage := self ownerOrYourselfThatIsAPhratchStageMorph.	
	stage ifNil: [^ self].
	"add imported global custom block definitions"


	customBlocks ifNotNil: [

		'installing globals...' 
			displayProgressAt: self center - (32@5)  "Sensor cursorPoint"
			from: 0 to: customBlocks size
			during: [:bar | | i | i := 0.

		customBlocks do: [:eachDef | 
			i := i + 1. bar value: i.
			eachDef isGlobal ifTrue: [
				stage sprites, {stage} do: [:obj |
					obj
						updateCustomBlockDefinitionId: eachDef id with: eachDef;
						updateLocalId: eachDef id withSpec: eachDef userSpec]]]]].


]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> instances [

	| stage |
	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ifNil: [^ #()].
	^ stage sprites select: [:each |
		each prototype = self ]
]

{ #category : #byob }
ScriptablePhratchMorph >> instancesOf: aCustomBlockId [

	| sf ans visible invisible blx |
	invisible := self invisibleInstancesOf: aCustomBlockId.
	visible := (blocksBin allMorphs select: [ :m|
		((m isCustomCommandBlockMorph) or:[
			m isCustomReporterBlockMorph]) and: [m id = aCustomBlockId]]) asOrderedCollection.
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNotNil: [
		sf blockEditors do: [:be |
			blx := be allBlocksFor: aCustomBlockId.
			blx size > 0 ifTrue: [
				visible addAll: blx ]]].

	ans := visible, invisible.
	^ans
]

{ #category : #private }
ScriptablePhratchMorph >> interpretStringAsNumberIfPossible: anObject [
	"If the argument is a string that can be interpreted as a number, such as '123', then return it's value as a number. Otherwise, return the original object."

	| s digits hasDigit |
	(anObject isString)
		ifFalse: [ ^ anObject ].
	anObject size = 0
		ifTrue: [ ^ anObject ].
	s := (anObject first isCharacter)
		ifTrue: [ ReadStream on: anObject asByteArray ]
		ifFalse: [ ReadStream on: anObject ].	"see if the string can be parsed as a Phratch number:"
	digits := '0123456789' asByteArray.
	hasDigit := false.
	(s atEnd not and: [ s peek = $- asciiValue ])
		ifTrue: [ s next ].
	[ s atEnd not and: [ digits includes: s peek ] ]
		whileTrue: [ 
			hasDigit := true.
			s next ].
	(s atEnd not and: [ s peek = $. asciiValue ])
		ifTrue: [ s next ].
	[ s atEnd not and: [ digits includes: s peek ] ]
		whileTrue: [ 
			hasDigit := true.
			s next ].
	(s atEnd and: [ hasDigit ])
		ifTrue: [ ^ anObject asNumberNoError ]
		ifFalse: [ ^ anObject ]
]

{ #category : #byob }
ScriptablePhratchMorph >> invisibleInstancesOf: aCustomBlockId [

	| ans |
	ans := Set new.
	customBlocks ifNil: [^ ans].
	customBlocks do: [:eachDef|
		eachDef body ifNotNil: [
			ans addAll: (eachDef body allMorphs select: [:m|
				((m isCustomCommandBlockMorph) or: [
					m isCustomReporterBlockMorph]) and: [
				m id = aCustomBlockId ]])].

		eachDef answer ifNotNil: [
			(eachDef answer isBlockMorph) ifTrue: [
				ans addAll: (eachDef answer allMorphs select: [:m|
					(m isCustomReporterBlockMorph) and: [
					m id = aCustomBlockId ]])]]].

	^ans asOrderedCollection
]

{ #category : #accessing }
ScriptablePhratchMorph >> isClone [

	^ false

]

{ #category : #accessing }
ScriptablePhratchMorph >> isClone: aBoolean [
	"Ignored here. Overridden by my subclasses."
]

{ #category : #testing }
ScriptablePhratchMorph >> isFibonacci: t1 [ 
	"Return true if the given number is in the Fibonacci sequence"
	<phratchItem: '$Number$ is a Fibonacci number?' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a9 special: #()>
    | fib1 fib2 oldfib2 fib3 oldfib3 |
                t1 isInf ifTrue:[^false].
                t1 isNaN ifTrue:[^false].
                t1 < 0 ifTrue: [^ false].
    t1 = 0 ifTrue: [^ true].
    t1 = 1 ifTrue: [^ true].
    fib1 := 0.
    fib2 := 1.
    oldfib2 := fib2.
    fib3 := fib1 + fib2.
    oldfib3 := fib3.
    [t1 > fib3]
        whileTrue: 
            [fib3 := fib1 + fib2.
            fib2 := oldfib3.
            fib1 := oldfib2.
            oldfib3 := fib3.
            oldfib2 := fib2].
    t1 = fib3 ifTrue: [^ true]
		 ifFalse: [^ false]

]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> isHidden [

	| att |
	att := #isHidden.
	self prototype ifNotNil: [
		(self deletedAttributes includes: att) ifTrue: [
			^ self prototype get: att]].

	^ super isHidden


]

{ #category : #testing }
ScriptablePhratchMorph >> isInteger: t1 [
	"Return true if the given value is an integer"
	<phratchItem: '$String$ is an integer?' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a9 special: #()>
	|int|
	[int:= t1 asNumber] on: Error do: [ ^false ].

    ^ int = int rounded
]

{ #category : #byob }
ScriptablePhratchMorph >> isObject: object type: type [
	"Return true if the given object is a kind of given type"
	<phratchItem: 'is $String$ a $Type$ ?' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a9 special: #()>
	'object' "localized" = type ifTrue: [
		^ object isScriptablePhratchMorph].

	'number' "localized" = type ifTrue: [
		object isNumber ifTrue: [^true].
		(object isMorph) ifTrue: [^ false].
		(object isBoolean) ifTrue: [^ false].
		object isEmpty ifTrue: [^ false].
		object do: [:c | 
			c isDigit ifFalse: [('0.-' includes: c) ifFalse: [^ false]]].
		^ true].

	'text' "localized" = type ifTrue: [
		object isNumber ifTrue: [^ false].
		(object isMorph) ifTrue: [^ false].
		(object isBoolean) ifTrue: [^ false].
		object isEmpty ifTrue: [^ true].
		object do: [:c | 
			c isDigit ifFalse: [('0.-' includes: c) ifFalse: [^ true]]].
		^ false].

	'boolean' "localized" = type ifTrue: [
		^ object isBoolean].

	'list' "localized" = type ifTrue: [
		^ object isPhratchListMorph]. 

	'command' "localized" = type ifTrue: [
		^ (object isLambdaBlockMorph) and:[
		object isFunction not]].

	'reporter' "localized" = type ifTrue: [
		(object isLambdaBlockMorph) ifFalse: [^ false].
		object isBooleanFunction ifTrue: [^ false].
		^ object isFunction].

	'predicate' "localized" = type ifTrue: [
		(object isLambdaBlockMorph) ifFalse: [^ false].
		^ object isBooleanFunction].

	^ false



]

{ #category : #testing }
ScriptablePhratchMorph >> isPrime: t1 [ 
	"Return true if the given integer is prime"
	<phratchItem: '$Number$ is prime?' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a9 special: #()>
    | divisor factor |
    t1 isInf ifTrue: [^ false].
    t1 isNaN ifTrue: [^ false].
    t1 < 1 ifTrue: [^ false].
    t1 = 1 ifTrue: [^ false].
    t1 = t1 rounded ifFalse:[^false].
    divisor := 2.
    [divisor > (0.5 * t1)]
        whileFalse: 
            [factor := t1 / divisor.
            factor = factor rounded ifTrue: [^false].
            divisor := divisor + 1].
    ^ true
]

{ #category : #accessing }
ScriptablePhratchMorph >> isScriptable [
	"I am a scriptable Phratch object."

	^ true

]

{ #category : #testing }
ScriptablePhratchMorph >> isScriptablePhratchMorph [
	"I am a scriptable Phratch object."

	^ true

]

{ #category : #accessing }
ScriptablePhratchMorph >> isSprite [

	^ false

]

{ #category : #accessing }
ScriptablePhratchMorph >> isVisible [

	^ self isHidden not and: [visibility > 0]

]

{ #category : #'dropping/grabbing' }
ScriptablePhratchMorph >> justDroppedInto: newOwner event: evt [
	"If I'm dropped into any submorph of a PhratchFrameMorph, reject the drop unless it is onto the work pane. For developers, accept drops into other morphs (e.g. the World). Otherwise, reject the drop."

	| sFrame |
	(sFrame := newOwner ownerOrYourselfThatIsAPhratchFrameMorph) ifNotNil: [
		newOwner = sFrame viewerPane pageViewer contents ifTrue: [
			self undoableDeleteSprite.
			sFrame libraryPane step.
			^ self].

		newOwner = sFrame workPane ifTrue: [^ self]. "allow drops onto the work pane"
		^ evt hand rejectDropMorph: self event: evt].

	ScriptablePhratchMorph noviceMode ifTrue: [^ evt hand rejectDropMorph: self event: evt].

]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> keyNames [
	"Key names for 'key pressed' block menu. Must keep this list in sync with asciiFor:."

	^ #('up arrow' 'down arrow' 'right arrow' 'left arrow' 'space'),
	   ($a to: $z), ($0 to: $9)
		 collect: [:ch | ch asString]

]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> keyPressed: keyName [
	"Return true if the currently pressed key is the given argument."
	<phratchItem: 'key $Keys$ pressed?' kind: #BooleanBlockMorph category: 'sensing' defaultValues: #('space') subCategory: #a2 special: #()>
	| ch |
	ch := self asciiFor: keyName.
	(Sensor keyPressed: ch) ifTrue: [^ true].

	"if key is a letter, check the opposite case"
	(ch between: $a asciiValue and: $z asciiValue) ifTrue: [
		^ Sensor keyPressed: ch - 32].
	(ch between: $A asciiValue and: $Z asciiValue) ifTrue: [
		^ Sensor keyPressed: ch + 32].

	^ false

]

{ #category : #byob }
ScriptablePhratchMorph >> lambda: aCustomBlockId [

	"used for the getAttribute block menu"

	| def block |
	
	aCustomBlockId isEmpty ifTrue: [^nil].

	def := self definitionFor: aCustomBlockId.
	(def isNil or: [#none = def type])
		ifTrue: [block := CustomCommandBlockMorph new receiver: self]
		ifFalse: [
			block := CustomReporterBlockMorph new receiver: self.
			block isBoolean: def type = #boolean].

	block
		userSpec: def userSpec;
		isSpecialForm: true;
		selector: #doCustomBlock.

	block argMorphs do: [:arg |
		arg defaultValue: ''].

	^ block
	
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> layer [

	| att |
	att := #layer.
	self prototype ifNotNil: [
		(self deletedAttributes includes: att) ifTrue: [
			^ self prototype get: att]].

	^ owner submorphs indexOf: self
]

{ #category : #media }
ScriptablePhratchMorph >> layer: aNumber [

	| n submorphsMinusMe newSubmorphs |
	owner ifNil: [^ 1].
	n := (aNumber rounded max: 1) min: owner submorphCount.
	submorphsMinusMe := owner submorphs copyWithout: self.
	newSubmorphs :=
		(submorphsMinusMe copyFrom: 1 to: (n - 1 min: submorphsMinusMe size)),
		(Array with: self),
		(submorphsMinusMe copyFrom: n to: submorphsMinusMe size).
	owner privateSubmorphs: newSubmorphs.
	self changed.
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> layoutStyles [

	^ #(
		'small'
		'large'
		'slider'
		).
]

{ #category : #'string ops' }
ScriptablePhratchMorph >> letter: index of: anObject [
	"Answer the ith letter of the given string. Answer the empty string if the index is out of bounds."
	<phratchItem: 'letter $Number$ of $String$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(1 'world') subCategory: #a6 special: #()>
	| s i |
	s := anObject.

	s := anObject asString.

	i := self letterNum: index of: s.
	((i < 1) | (i > s size)) ifTrue: [^ ''].
	^ (String with: (s at: i))

]

{ #category : #'string ops' }
ScriptablePhratchMorph >> letterNum: letterNum of: aString [
	"Answer the ith letter of the given string. Answer the empty string if the index is out of bounds."

	| s |
	letterNum isNumber ifTrue: [^ letterNum asInteger].

	s := letterNum.
	(s isString) ifTrue: [
		#first = s ifTrue: [^ 1].
		#last = s ifTrue: [^ aString size].
		#any = s ifTrue: [
			aString size = 0 ifTrue: [^ 1].
			^ (1 to: aString size lineCount) atRandom].
		^ s asNumberNoError].
	^ 0

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> letters: start through: end of: aString [
	"Return the letters in a string from the start index through the end index."
	<phratchItem: 'letters $Number$ - $Number$ of $String$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(1 5 'hello world') subCategory: #a6 special: #()>
	^ aString asString copyFrom: (start max: 1) to: (end min: aString size).
]

{ #category : #'list ops' }
ScriptablePhratchMorph >> listIndexForDeleteMenu [

	| menu |
	menu := MenuMorph new defaultTarget: self.
	#('1' last) do: [:s | menu add: s value: s].
	menu addLine.
	menu add: #all value: #all.
	menu localize invokeModal.
	^ menu 

]

{ #category : #'list ops' }
ScriptablePhratchMorph >> listNamed: aString [

	^ self listNamed: aString ifNone: [nil]
]

{ #category : #'list ops' }
ScriptablePhratchMorph >> listNamed: aString ifNone: aBlock [
	"Answer a list with the given name. First check the local list variables, otherwise check the global list variables and the prototype. If there is no list variable with the given name, return the result of evaluating the given block."

	| result stage |
	(aString isPhratchListMorph)
		ifTrue: [^aString ].
	(result := lists at: aString ifAbsent: [nil]) ifNotNil: [^ result].

	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [
		(result := stage lists at: aString ifAbsent: [nil]) ifNotNil: [^ result]].

	self prototype ifNotNil: [^ self prototype listNamed: aString ifNone: aBlock].

	^ aBlock value



]

{ #category : #'list ops' }
ScriptablePhratchMorph >> listVarMenu [
	"Answer a menu for selecting a list variables."

	| result stage |
	result := #().
	((stage := self ownerOrYourselfThatIsAPhratchStageMorph) notNil & (stage ~= self)) ifTrue: [
		result := stage listVarNames].

	self listVarNames size > 0 ifTrue: [
		result size > 0 ifTrue: [result := result copyWith: '-'].
		result := result, self listVarNames].

	result size > 0
		ifTrue: [^ #(''), result]
		ifFalse: [^ result]

]

{ #category : #'list ops' }
ScriptablePhratchMorph >> listVarNames [
	"Answer a list of list variable names."

	| lst |
	lst := lists keys asOrderedCollection.
	self prototype ifNotNil: [
		lst addAll: self prototype listVarNames ].

	^ lst asSet asArray sort


]

{ #category : #'list ops' }
ScriptablePhratchMorph >> lists [

	^ lists

]

{ #category : #byob }
ScriptablePhratchMorph >> localBlocks [
	^ self inheritedBlocks , (customBlocks ifNil: [ #() ]) reject: [ :eachDef | eachDef isGlobal ]
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> lookLike: costumeNameOrIndex [
	"Change to the costume indicated by the given name, index, or boolean. Noop if there is no costume of the given name in my library."
	"Note: Costumes can have names that look like numbers, but those numbers have nothing to do with the index of the costume. So, we first try interpreting the argument as a name. If that fails, we try interpreting it as a costume index number."

	| p newCostume i |
	p := self referencePosition.
	costume suspendPlaying.

	newCostume := nil.
	(costumeNameOrIndex isString) ifTrue: [
		"try interpreting the argument as a costume name"
		newCostume := self costumeFromName: costumeNameOrIndex.

		"try interpreting the string as a number"
		newCostume ifNil: [
			i := self interpretStringAsNumberIfPossible: costumeNameOrIndex.
			i isNumber ifTrue: [
				newCostume := self costumeFromName: (self costumeNameFromNumber: i)]
				ifFalse: [^ self]]].  "string does not match a costume and cannot be coverted to a number"

	"treat other types (number, boolean) as a costume index"
	newCostume ifNil: [
		i := costumeNameOrIndex asNumberNoError.
		newCostume := self costumeFromName: (self costumeNameFromNumber: i)].

	newCostume ifNil: [^ self].  "should not happen..."

	costume := newCostume.
	self setSizeTo: self scale.		"adjust the size if it is really huge or tiny.-jens"
	costume resumePlaying.
	self costumeChanged.
	self referencePosition: p.
	World displayWorldSafely.

]

{ #category : #'right button menu' }
ScriptablePhratchMorph >> makeVisible [
	"Make sure that I am entirely on the screen and visible."

	self isHidden ifTrue: [self isHidden: false].
	"visibility < 30 ifTrue: [self setGraphicEffect: 'ghost' to: 100]."
	self scale < 10 ifTrue: [self setSizeTo: 100].
	(owner notNil and: [owner bounds containsPoint: self center]) ifFalse: [
		self gotoX: 0 y: 0 ].
	self comeToFront.
	World displayWorldSafely.

"	self viewBlocksAndScriptsQuickly."

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> mathFunctionNames [
	"Answer a collection of math function names."

	^ #(
		'abs'
		'sqrt'
		'sin'
		'cos'
		'tan'
		'asin'
		'acos'
		'atan'
		'ln'
		'log'
		'e ^'
		'10 ^')

]

{ #category : #accessing }
ScriptablePhratchMorph >> media [

	^ media

]

{ #category : #media }
ScriptablePhratchMorph >> mediaNameFromFileName: fileName default: defaultName [
	"Answer a name for the given media item. If the existing name is '$$squeak$$' then the media was copied via windows drag-and-drop; use the given default name instead."

	| result |
	result := fileName basename.
	(result beginsWith: '$$squeak$$') ifTrue: [result := defaultName].
	result size > 16 ifTrue: [result := result copyFrom: 1 to: 16].
	^ result

]

{ #category : #'event handling' }
ScriptablePhratchMorph >> mouseDown: evt [
	"Handle a mouse click. Left button either drags or performs click action. Right button brings up a menu."

	evt hand newKeyboardFocus: nil.

	evt hand toolType ifNotNil: [
		self handleTool: evt hand toolType hand: evt hand.
		^ self].

	(owner isPhratchStageMorph) ifFalse: [^ super mouseDown: evt].

	evt rightButtonPressed
		ifTrue: [Sensor waitNoButton. ^ self rightButtonMenu]
		ifFalse:	[evt hand waitForClicksOrDrag: self event: evt].
]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> mouseX [
	"Give the x position of the mouse"
	<phratchItem: 'mouse x' kind: #ReporterBlockMorph category: 'sensing' defaultValues: #() subCategory: #a21 special: #()>
	| s centerX |
	DoubleSize ifTrue: [^ (Sensor lastMousePosition x - PhratchOrigin x) // 2].

	self inPresentationMode ifFalse: [
		s := self ownerOrYourselfThatIsAPhratchStageMorph.
		(s notNil and: [s isQuarterSize]) ifTrue: [
			centerX := s left + (s width // 4).
			^ 2 * (Sensor lastMousePosition x - centerX)]].

	^ Sensor lastMousePosition x - PhratchOrigin x

]

{ #category : #'sensing ops' }
ScriptablePhratchMorph >> mouseY [
	"Give the y position of the mouse"	
	<phratchItem: 'mouse y' kind: #ReporterBlockMorph category: 'sensing' defaultValues: #() subCategory: #a21 special: #()>
	| s centerY |
	DoubleSize ifTrue: [^ (Sensor lastMousePosition y - PhratchOrigin y) negated // 2].

	self inPresentationMode ifFalse: [
		s := self ownerOrYourselfThatIsAPhratchStageMorph.
		(s notNil and: [s isQuarterSize]) ifTrue: [
			centerY := s top + (s height // 4).
			^ -2 * (Sensor lastMousePosition y - centerY)]].

	^ (Sensor lastMousePosition y - PhratchOrigin y) negated

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> moveVar: aVarName toX: x y: y [
	"Move the watcher of the given variable at the position x,y. Do nothing if the watcher is hidden"
	<phratchItem: 'move $Variable$ to x: $Number$ y: $Number$' kind: #- category: 'variables' defaultValues: #('' 0 0) subCategory: #a5 special: #()>
	| stage |
	self positionVar: aVarName atX: x y: y.

	stage := self ownerThatIsAPhratchStageMorph.
	stage ~= self ifTrue: [stage positionVar: aVarName atX: x y: y].
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> mwait: duration elapsed: elapsed from: ignored [
	"Do nothing; just wait for the time interval to elapse."

	^ nil

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> n: aNumber toPower: aPower [
	"Return the power n of the given number."
	<phratchItem: '$Number$ ^ $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(- -) subCategory: #a1 special: #()>
	^ aNumber raisedTo: aPower
]

{ #category : #byob }
ScriptablePhratchMorph >> neg: aNumber [
	"Returns the negation of a number"
	<phratchItem: 'neg $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(- -) subCategory: #a1 special: #()>
^ -1 * aNumber
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> newCostumeTypes [

	^ #('camera'
		'stage'
		'paint new'
		'import').
]

{ #category : #byob }
ScriptablePhratchMorph >> newCustomBlockFor: aDefinition [

	| b |

	#none = aDefinition type
		ifTrue: [b := CustomCommandBlockMorph new receiver: self]
		ifFalse: [
			b := CustomReporterBlockMorph new receiver: self.
			b isBoolean: (aDefinition type = #boolean)].
	b userSpec: aDefinition userSpec.
	b isSpecialForm: true.
	b selector: #doCustomBlock.
	b setDefaultArgs.
	^ b

]

{ #category : #private }
ScriptablePhratchMorph >> nextInstanceName [
	"Answer a name for a new instance. For sprites, an attempt is made to create a unique name of the form 'spriteN'."

	| stage lastN digits |
	self = PhratchStageMorph ifTrue: [^ 'Stage' localized].

	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNil: [^ 'Sprite' localized, 1 printString].
	lastN := 0.
	stage sprites ifNotNil: [
		stage sprites do: [:m |
			(m isPhratchSpriteMorph) ifTrue: [
				digits := m objName trailingDigits.
				((digits size > 0) and: [m objName beginsWith: ('Sprite' localized)])
					ifTrue: [lastN := lastN max: digits asNumber]]]].

	^ 'Sprite' localized, (lastN + 1) printString

]

{ #category : #byob }
ScriptablePhratchMorph >> not [
	"Not operator. It is applied on a boolean"
	<phratchItem: 'not $Boolean$' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a4 special: #()>

]

{ #category : #byob }
ScriptablePhratchMorph >> notEditingBlock [
	| sf |
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNil: [^true].
	^sf notEditingBlock
]

{ #category : #byob }
ScriptablePhratchMorph >> number: n1 compare: anOp on: n2 [
	"Divider operator. It combines two numbers and returns a number"
	<phratchItem: '$Number$ $Comparator$ $Number$' kind: #BooleanBlockMorph category: 'operators' defaultValues: #(10 '=' 10) subCategory: #a0 special: #()>
	^ n1 perform: anOp asSymbol with: n2
]

{ #category : #byob }
ScriptablePhratchMorph >> number: n1 operator: anOp on: n2 [
	"Divider operator. It combines two numbers and returns a number"
	<phratchItem: '$Number$ $Operator$ $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(10 '+' 10) subCategory: #a0 special: #()>
	^ n1 perform: anOp asSymbol with: n2
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> numberToInteger: aString [
	"Answer the given string as an integer."
	<phratchItem: '$String$ as integer' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('1.0') subCategory: #a4 special: #()>
	| s |
	s := aString asInteger.
	^ s
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> numericConstant: t1 [ 
	"Return the value of the given constant"
	<phratchItem: '$Constants$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('pi') subCategory: #a2 special: #()>
	'pi' = t1 ifTrue: [^ Float pi].
	'e' = t1 ifTrue: [^ Float e].
	'newline' = t1 ifTrue: [^ String crlf].
	'tab' = t1 ifTrue: [^ '	']
]

{ #category : #accessing }
ScriptablePhratchMorph >> objName [
	"Return myself"
	<phratchItem: 'self' kind: #ReporterBlockMorph category: 'control' defaultValues: #() subCategory: #self special: #()>
	^ objName

]

{ #category : #accessing }
ScriptablePhratchMorph >> objName: aString [

	"don't allow renaming a sprite to use a name already in use"
	(self spriteNameInUse: aString) ifTrue: [^ self].
	objName := aString.
	objName size = 0 ifTrue: [objName := self nextInstanceName].

]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> objectInterface [

	|s|
	s := Dictionary new.
	PhratchCategory allSubclassesDo: [:e | s addAll: e objectInterface].
	s addAll: PhratchCategory objectInterface.
	^ s
]

{ #category : #media }
ScriptablePhratchMorph >> onlyCostume: aForm [
	"Remove all my costumes, then make a new costume using the given Form."

	| el |
	media := media select: [:m | m isSound].

	el := ImageMedia new form: aForm.
	el mediaName: 'costume'.
	media addLast: el.
	self lookLike: el mediaName.
	self updateMediaCategory.

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> openCamera [
	"Open the camera if close. If it is already open, the block does nothing"
	<phratchItem: 'open camera' kind: #- category: 'looks' defaultValues: #() subCategory: #a9 special: #()>
	self cameraIsOpen ifFalse: [
			(CameraPlugin openCamera: 1 width: 480 height: 360) ifNotNil: [
				CameraPlugin waitForCameraStart.]
	].
	CameraOpenings := CameraOpenings +1.
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> passiveLookLike: costumeName [

	self subclassResponsibility 
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> passiveSetLayerTo: aNumber [

	self layer: aNumber asNumberNoError truncated.
	self spread.
	self propagate: #layer
]

{ #category : #menu }
ScriptablePhratchMorph >> pause [
	"Pause the main process and wait the user click on the OK button"
	<phratchItem: 'pause' kind: #- category: 'control' defaultValues: #() subCategory: #startstop special: #()>
    DialogBoxMorph inform: 'Paused: Click OK to continue'.
	self updateAfterPopUp.
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> penDown [
	"Overriden by sprites."

	^ false

]

{ #category : #'message performing' }
ScriptablePhratchMorph >> perform: selector withArguments: argArray [ 

	^ [super perform: selector withArguments: argArray] on: Error do:
		[ 
		self = phratchModel ifFalse:[
			phratchModel perform: selector withArguments: argArray ]
		]
]

{ #category : #scripts }
ScriptablePhratchMorph >> phratchFrame [

	| frame w |
	frame := self ownerOrYourselfThatIsAPhratchFrameMorph.
	frame ifNil: [
		(w := self ownerOrYourselfThatIsAOffscreenWorldMorph) ifNil: [^ nil].
		frame := w frame].
	^ frame


]

{ #category : #accessing }
ScriptablePhratchMorph >> phratchModel [
	"Answer my current costume form, without filtering, rotation, or scaling."

	^ phratchModel

]

{ #category : #accessing }
ScriptablePhratchMorph >> phratchModel: anObject [

	phratchModel := anObject
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> positionVar: varName atX: x y: y [
	| frame w b newX newY p |
	(self varNames includes: varName)
		ifFalse: [ ^ self ].
	frame := self ownerThatIsAPhratchFrameMorph.
	frame
		ifNil: [ 
			(w := self ownerThatIsAOffscreenWorldMorph) ifNil: [ ^ self ].
			frame := w frame ].
	b := VariableBlockMorph new
		commandSpec: varName;
		receiver: self blockReceiver;
		yourself.
	(w := frame watcherForBlock: b) ifNil: [ ^ self ].
	newX := x.
	newX isNaN
		ifTrue: [ newX := 0 ].
	newX := newX min: 240.
	newX := newX max: -240 - w extent x.
	newY := y.
	newY isNaN
		ifTrue: [ newY := 0 ].
	newY := newY max: -180.
	newY := newY min: 180 + w extent y.
	p := newX @ newY negated.
	w position: PhratchOrigin + p
]

{ #category : #scripts }
ScriptablePhratchMorph >> prepareForExport [
	self blocksBin allMorphsDo: [:m |
		(m isBlockMorph) ifTrue: [m stop].
		(m isSpriteArgMorph) ifTrue: [m clearMorphReference]].

	customBlocks ifNotNil: [
		customBlocks do: [:eachDef |
			eachDef body ifNotNil: [
				eachDef body allMorphsDo: [:m |
					(m isSpriteArgMorph) ifTrue: [m clearMorphReference]]].
			(eachDef answer isMorph) ifTrue: [
				eachDef answer allMorphsDo: [:m |
					(m isSpriteArgMorph) ifTrue: [m clearMorphReference]]]]].

]

{ #category : #'block API' }
ScriptablePhratchMorph >> pressGreenFlag [
	"Make like if the user presses the Green flag."
	<phratchItem: 'press green flag' kind: #- category: 'control' defaultValues: #() subCategory: #startstop special: #()>
	| sFrame |
	sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sFrame pressGreenFlagButton
]

{ #category : #private }
ScriptablePhratchMorph >> printSummaryOn: aStream [
	| costumes snds stacks hats otherStacks |
	aStream
		nextPutAll: 'Sprite: ';
		nextPutAll: self objName;
		crlf.
	costumes := media select: [ :item | item isImage ].
	aStream
		nextPutAll: '  Costumes (';
		nextPutAll: costumes size printString;
		nextPutAll: '):';
		crlf.
	costumes
		do: [ :item | 
			aStream
				nextPutAll: '    ';
				nextPutAll: item mediaName;
				nextPutAll: ' (';
				nextPutAll: item infoString;
				nextPutAll: ')';
				crlf ].
	snds := media select: [ :item | item isSound ].
	aStream
		nextPutAll: '  Sounds (';
		nextPutAll: snds size printString;
		nextPutAll: '):';
		crlf.
	snds
		do: [ :item | 
			aStream
				nextPutAll: '    ';
				nextPutAll: item mediaName;
				nextPutAll: ' (';
				nextPutAll: item infoString;
				nextPutAll: ')';
				crlf ].
	stacks := blocksBin submorphs select: [ :m | m isBlockMorph ].
	stacks size = 0
		ifTrue: [ 
			aStream
				nextPutAll: '  No stacks.';
				crlf;
				crlf.
			^ self ].
	aStream
		nextPutAll: '  Stacks (';
		nextPutAll: stacks size printString;
		nextPutAll: '):';
		crlf.
	hats := stacks select: [ :m | m isHatBlockMorph ].
	otherStacks := stacks reject: [ :m | m isHatBlockMorph ].
	hats , otherStacks
		do: [ :item | 
			item printCodeOn: aStream indent: 1.
			(item isReporterBlockMorph)
				ifTrue: [ aStream crlf ].
			aStream crlf ]
]

{ #category : #'blocks API' }
ScriptablePhratchMorph >> procedure [
	"Return the given script without executing it"
	<phratchItem: 'the script' kind: #CommandScriptBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>
]

{ #category : #'blocks API' }
ScriptablePhratchMorph >> procedureWithArgs [
"Return the given script with arguments without executing it"
	<phratchItem: 'the script. Input names: $String$' kind: #CommandScriptBlockMorph category: 'control' defaultValues: #() subCategory: #process special: #()>
]

{ #category : #private }
ScriptablePhratchMorph >> projectDirectory [
	"Answer the directory containing this Phratch project or the default directory."

	| frame |
	(frame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ FileSystem workingDirectory].
	^ frame projectDirectory

]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> propagate: attributeName [
	"private - apply the method calling me to all subsprites"

	| sel args instances |
	instances := self instances select: [:each |
		each deletedAttributes includes: attributeName].
	instances isEmpty ifTrue: [^self].
	sel := thisContext sender method selector.
	args := OrderedCollection new.
	1 to: thisContext sender method numArgs do: [:idx |
		args add: (thisContext sender tempAt: idx) ].
	instances do: [:eachPart |
		args isEmpty
			ifTrue: [ eachPart perform: sel]
			ifFalse: [ eachPart perform: sel withArguments: args asArray]]
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> propagateCostumes [

	self instances do: [:child |
		child inheritCostumesNow]
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> propagateSounds [

	self instances do: [:child |
		child inheritSoundsNow]
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> prototype [
	(self isPhratchSpriteMorph)
		ifTrue: [^ self prototype]
		ifFalse: [^ nil]
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> randomFrom: start to: stop [
	"Answer a random number within the given range. If both min and max are integers, the result is rounded to the nearest integer."

	<phratchItem: 'pick random $Number$ to $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(1 10) subCategory: #a2 special: #()>
	| min max result random |
	random := Random new.
	min := start min: stop.
	max := start max: stop.
	result := random next * (max - min) + min.
	result := min isInteger & max isInteger
		ifTrue: [ (random next * (max + 1 - min)) truncated + min ]
		ifFalse: [ random next * (max - min) + min ].
	^ result
]

{ #category : #'dropping/grabbing' }
ScriptablePhratchMorph >> rejectDropEvent: evt [
	"Reject being dropped by the given event."

	(self owner isPhratchStageMorph)
		ifFalse: [ ^ evt hand rejectDropMorph: self event: evt ]
		ifTrue: [ ^ false ]
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> reportVar: varName [
	"Answer the value of the given variable."
	<phratchItem: '$Variable$' kind: #ReporterBlockMorph category: 'variables' defaultValues: #('') subCategory: #a3 special: #()>
	| stage |
	(self varNames includes: varName)
		ifTrue: [^ self getVar: varName].
	(stage := self ownerThatIsAPhratchStageMorph)
		ifNotNil: [^ stage getVar: varName]

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> returnW: aTypeString [
	"Return the date and time current value"
	<phratchItem: 'date/time: $TimeDates$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #() subCategory: #a2 special: #()>
	| time date |
	time := Time now.
	date := Date today.
	'time' = aTypeString ifTrue: [^ time asString].
	'hour' = aTypeString ifTrue: [^ time hours].
	'minute' = aTypeString ifTrue: [^ time minutes].
	'second' = aTypeString ifTrue: [^ time seconds].
	'date' = aTypeString ifTrue: [^ date asString].
	'weekday-name' = aTypeString ifTrue: [^ date weekday].
	'weekday-#' = aTypeString
		ifTrue: 
			[date weekday = 'Monday' ifTrue: [^ 1].
			date weekday = 'Tuesday' ifTrue: [^ 2].
			date weekday = 'Wednesday' ifTrue: [^ 3].
			date weekday = 'Thursday' ifTrue: [^ 4].
			date weekday = 'Friday' ifTrue: [^ 5].
			date weekday = 'Saturday' ifTrue: [^ 6].
			date weekday = 'Sunday' ifTrue: [^ 7]].
	'month-name' = aTypeString ifTrue: [^ date monthName asString].
	'month-#' = aTypeString ifTrue: [^ date monthIndex].
	'day of month' = aTypeString ifTrue: [^ date dayOfMonth].
	'day of year' = aTypeString ifTrue: [^ date daysInYear - date daysLeftInYear].
	'year' = aTypeString ifTrue: [^ date year].
	^ 0
]

{ #category : #media }
ScriptablePhratchMorph >> revertToCostume: oldCostumeName [
	"Sent by the paint editor if editing of a newly-created costume is cancelled. Delete the new costume and revert to the old costume with the given name."

	| newlyCreatedCostume |
	newlyCreatedCostume := costume.
	self lookLike: oldCostumeName.
	media remove: newlyCreatedCostume ifAbsent: [].
	self updateMediaCategory.

	self undeleteAttribute: #costumes.
	self propagateCostumes

]

{ #category : #'right button menu' }
ScriptablePhratchMorph >> rightButtonMenu [
	"This default implementation does nothing."

]

{ #category : #accessing }
ScriptablePhratchMorph >> rotatedForm [
	"By default, just return my costume form. Sprites override this method to do rotation."

	^ self costumeForm


]

{ #category : #accessing }
ScriptablePhratchMorph >> rotationCenter: aPoint [
	"Set my costume's rotation center."

	costume rotationCenter: aPoint.
	self costumeChanged.

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> rounded [
	"Return the rounded value of the given argument"
	<phratchItem: 'round $Number$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #(-) subCategory: #a1 special: #()>

]

{ #category : #media }
ScriptablePhratchMorph >> savePhoto: aForm [

	| n |
	n := self unusedMediaNameFromBaseName: 'costume' localized, '1'.
	self addMediaItem: (ImageMedia new mediaName: n; form: aForm;
		yourself).

	self undeleteAttribute: #costumes.
	self propagateCostumes



]

{ #category : #'block API' }
ScriptablePhratchMorph >> saveProj [
	"Save the current project"
	<phratchItem: 'save project' kind: #- category: 'control' defaultValues: #() subCategory: #project special: #()>
| t1 |
t1 := self ownerThatIsAPhratchFrameMorph.
t1 savePhratchProject
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> sayNothing [
	"Default behavior does nothing. Overridden in PhratchSpriteMorph."

]

{ #category : #accessing }
ScriptablePhratchMorph >> scale [

	^0
]

{ #category : #accessing }
ScriptablePhratchMorph >> scalePoint [

	^0@0
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> sceneNames [

	^ (self ownerOrYourselfThatIsAPhratchStageMorph) sceneNames

]

{ #category : #scripts }
ScriptablePhratchMorph >> scripts [
	"Answer my scripts, a collection of HatBlockMorphs."

	(blocksBin isMorph) ifFalse: [^ blocksBin].
	^ blocksBin submorphs select: [:m | m isHatBlockMorph]

]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> set: anObject to: aValue [
	"Set the given attribute to the given value"
	<phratchItem: 'set $Attributes$ to $String$' kind: #- category: 'sensing' defaultValues: #() subCategory: #a3 special: #()>
	| oi sel obj att block arg |
	oi := self objectInterface.
	(anObject isSymbol)
		ifTrue: [ 
			sel := oi at: anObject ifAbsent: [ ^ self error: 'unknown attribute: ' , anObject asString ].
			sel third = #-
				ifTrue: [ ^ self error: 'cannot set r/o attribute' ].
			^ self perform: sel third with: aValue ].
	(anObject isString)
		ifTrue: [ ^ self setVar: anObject to: aValue ].
	(anObject isCommandScriptBlockMorph)
		ifTrue: [ 
			obj := anObject receiver.
			(obj isScriptablePhratchMorph)
				ifFalse: [ ^ self error: 'cannot get attributes of non-Sprites/Stage' ].
			block := anObject body argMorphs first.
			(block isVariableBlockMorph)
				ifTrue: [ ^ obj setVar: block variable to: aValue ].
			#get: = block selector
				ifTrue: [ 
					arg := block argumentAt: 1.
					att := (arg isChoiceArgMorph)
						ifTrue: [ (block argumentAt: 1) choice ]
						ifFalse: [ (block argumentAt: 1) evaluate ] ]
				ifFalse: [ 
					att := oi keys
						detect: [ :key | (oi at: key) second = block selector ]
						ifNone: [ ^ self error: 'no attribute found for selector: ' , anObject selector ] ].
			^ obj set: att to: aValue ].
	self error: [ 'cannot set this value' ]
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> setLayerTo: aNumber [

	self undeleteAttribute: #layer.
	self passiveSetLayerTo: aNumber
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> setLayoutOfVar: varName to: aString [
	"Set the given watcher layout of the variable to the given style"
	<phratchItem: 'set layout of $Variable$ to $LayoutStyles$' kind: #- category: 'variables' defaultValues: #('' '') subCategory: #a5 special: #()>
	| symbol b w frame stage |
	symbol := aString asSymbol.
	frame := self ownerThatIsAPhratchFrameMorph.
	frame ifNil: [
		(w := self ownerThatIsAOffscreenWorldMorph) ifNil: [^ self].
		frame := w frame].
	(self varNames includes: varName) ifFalse: [
		stage := frame workPane.
		(stage varNames includes: varName) ifTrue: [^ stage setLayoutOfVar: varName to: aString.].].
	
	b := VariableBlockMorph new commandSpec: varName; receiver: self blockReceiver;
		yourself.
	w := frame watcherForBlock: b.
	w ifNotNil: [w layoutStyle: symbol].
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> setSizeTo: percent [

	^ self
]

{ #category : #variables }
ScriptablePhratchMorph >> setVar: varName to: newValue [
	"Set the value of the given variable of this object to the given value."
	<phratchItem: 'set $Variable$ to $String$' kind: #- category: 'variables' defaultValues: #('' '0') subCategory: #a0 special: #()>
	| vName stage sf w |

	"OOP interface:"
	(varName isCommandScriptBlockMorph) ifTrue: [
		^ self set: varName to: newValue].

	vName := varName asString. "convert Symbol to String if needed"
	(vars includesKey: vName) ifFalse: [
		(self prototype notNil and: [self prototype varNames includes: varName])
			ifTrue: [
				vars at: vName put: newValue.
				sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
				sf ifNil: [^ self].
				sf viewerPane categoryChanged: #variables.
				w := sf watcherForBlock: (VariableBlockMorph new 
						receiver: self; 
						commandSpec: varName; 
						yourself).
				w ifNotNil: [
				w setCategoryColor: (PhratchCategory blockColorFor: 'variables').
				^ self]].
			stage := self ownerOrYourselfThatIsAPhratchStageMorph.
		(stage notNil and: [stage ~= self]) 
			ifTrue: [stage setVar: varName to: newValue].
		^ self ].

	vars at: vName put: newValue.

]

{ #category : #variables }
ScriptablePhratchMorph >> showOrHideVariable: varName show: showFlag [
	"Show the watcher for the given variable. Do nothing if the variable does not exist or is already showing."

	| frame w b palette |
	(self varNames includes: varName) ifFalse: [^ self].
	frame := self ownerOrYourselfThatIsAPhratchFrameMorph.
	frame ifNil: [
		(w := self ownerOrYourselfThatIsAOffscreenWorldMorph) ifNil: [^ self].
		frame := w frame].

	b := VariableBlockMorph new commandSpec: varName; receiver: self blockReceiver;
		yourself.
	w := frame watcherForBlock: b.
	showFlag
		ifTrue: [w ifNil: [frame showWatcher: b createWatcher]]
		ifFalse: [w ifNotNil: [w delete]].

	palette := frame viewerPane pageViewer contents.
	palette ifNotNil: [palette updateWatcherButtonsForFrame: frame].

]

{ #category : #variables }
ScriptablePhratchMorph >> showVariable: varName [
	"Show the watcher(s) for the given variable. If the receiver is a sprite and both it and and the stage have the given variable, show both. Do nothing if the variable does not exist or is already showing."
	<phratchItem: 'show variable $Variable$' kind: #- category: 'variables' defaultValues: #() subCategory: #a2 special: #()>
	| stage |
	self showOrHideVariable: varName show: true.

	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ~= self ifTrue: [stage showOrHideVariable: varName show: true].


]

{ #category : #media }
ScriptablePhratchMorph >> soleCostume: imageMedia [
	"Make the given image my only costume."

	media := media reject: [ :item | item isImage ].
	self addMediaItem: imageMedia
]

{ #category : #'BYOB attributes' }
ScriptablePhratchMorph >> sounds [
	"this will at some future time answer first class sounds,
	for now it's just the sound names"

	^ PhratchListMorph on: ((media select: [:m | 
		m isSound]) collect: [:c | c mediaName])
]

{ #category : #nesting }
ScriptablePhratchMorph >> spread [
	"overridden by my subclasses. Default is to do nothing"
]

{ #category : #private }
ScriptablePhratchMorph >> spriteNameInUse: aString [

	| s |
	(s := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [
		s submorphs do: [:m |
			m == self ifFalse: [
				((m isScriptablePhratchMorph) and:
				 [m objName caseInsensitiveEqual: aString]) ifTrue: [
					^ true]]]].

	^ false

]

{ #category : #'event handling' }
ScriptablePhratchMorph >> startDrag: evt [
	"This is a drag gesture; pick me up."

	| rootForGrab |
	rootForGrab := owner rootForGrabOf: self.
	rootForGrab ifNil: [^ self].
	rootForGrab position: evt hand position + (self topLeft - evt cursorPoint).
	evt hand grabMorph: rootForGrab.

]

{ #category : #stepping }
ScriptablePhratchMorph >> step [

	costume mediaStep ifTrue: [self costumeChanged].

]

{ #category : #stepping }
ScriptablePhratchMorph >> stepTime [

	^ 0

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> stopAll [
	"Stop everything!"
	<phratchItem: 'stop all' kind: #- category: 'control' defaultValues: #() subCategory: #startstop special: #()>
	| stage |
	stage := self ownerOrYourselfThatIsAPhratchStageMorph.
	stage ifNotNil: [stage stopAll].

]

{ #category : #byob }
ScriptablePhratchMorph >> stopAllScriptsFor: eventName [
	"Stop all the scripts for the given event"
	<phratchItem: 'stop all scripts for $Event$' kind: #- category: 'control' defaultValues: #() subCategory: #startstop special: #()>
	| stage |
	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [
		stage stopAllScriptsFor: eventName].

]

{ #category : #private }
ScriptablePhratchMorph >> stopPlaying [
	"Stop playing all movies and sounds."

	| firstCostume |
	costume stopPlaying.
	self filterReset.
	(Smalltalk at: #PhratchCategorySound ifPresent:[self setVolumeTo: 100]).	"reset volume"	"exit camera mode"
	(costume isKindOf: CameraMedia)
		ifFalse: [ ^ self ].
	firstCostume := media detect: [ :el | el isImage ] ifNone: [ ^ self ].
	self lookLike: firstCostume mediaName
]

{ #category : #byob }
ScriptablePhratchMorph >> stopScriptsFor: eventName [
	"Stop all my running stacks with an EventHat matching the given event name."

	({'Phratch-KeyPressedEvent' . 'Phratch-MouseClickEvent'} includes: eventName)
		ifFalse: [ self scripts do: [:s |
			(((s class == EventHatMorph) or:[s class == StartEventHatMorph]) and: [s eventName caseInsensitiveEqual: eventName])
				ifTrue: [s stop]]]
]

{ #category : #'string ops' }
ScriptablePhratchMorph >> stringLength: anObject [
	"Return the number of characters of the given string"
	<phratchItem: 'length of $String$' kind: #ReporterBlockMorph category: 'operators' defaultValues: #('world') subCategory: #a6 special: #()>
	^ anObject asString size

]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> stringToBoolean: aString [
	"Answer the given string as a boolean."
	<phratchItem: '$String$ as boolean' kind: #BooleanBlockMorph category: 'operators' defaultValues: #('true') subCategory: #a4 special: #()>
	| s |
	s := aString asString.
	({'0' . '' . 'false'} includes: s) ifTrue: [^ false] ifFalse: [^ true].
]

{ #category : #media }
ScriptablePhratchMorph >> takePhoto [
	"Take a photo."

	PhratchCameraDialog new
		client: self;
		openInWorld;
		openCamera.

]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> thumbnailImageForm [

	^ self imageForm toThumbnail: 50@50 borderWidth: 0 borderColor: Color transparent
]

{ #category : #'panther actions' }
ScriptablePhratchMorph >> timeDates [
	^ #('time' 'hour' 'minute' 'second' 'date' 'day of month' 'day of year' 'weekday-name' 'weekday-#' 'month-name' 'month-#' 'year' )
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> undeleteAllAttributes [

	deletedAttributes := nil
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> undeleteAllBlocks [

	self inheritedBlocks do: [:eachDef |
		self ensureOwnBlockExists: eachDef]
]

{ #category : #'byob OOP' }
ScriptablePhratchMorph >> undeleteAllVariables [
	"... and lists"

	self varNames do: [:vn |
		self setVar: vn to: (self getVar: vn)].

	self listVarNames do: [:ln |
		lists at: ln put: (self listNamed: ln)]
]

{ #category : #'BYOB object interface' }
ScriptablePhratchMorph >> undeleteAttribute: aSymbol [

	| oi sf cat block w |
	deletedAttributes ifNil: [
		deletedAttributes := Set new].
	deletedAttributes remove: aSymbol ifAbsent: [^ nil].

	"update palette"
	
	oi := self objectInterface.
	sf := self phratchFrame.
	sf ifNil: [^ self].
	cat := (oi at: aSymbol) first.
	sf viewerPane categoryChanged: cat.

	"update watchers"

	block := self blockForSelector: ((oi at: aSymbol) second).
	block ifNil: [^ self].
	w := sf watcherForBlock: block.
	w ifNil: [^ self].
	w setCategoryColor: block color
]

{ #category : #media }
ScriptablePhratchMorph >> unusedMediaNameFromBaseName: baseName [
	"Answer an unused name for a new media item with the given base name. Strip off the file extension, if any."

	^ self unusedMediaNameFromBaseName: baseName forMedia: nil
]

{ #category : #media }
ScriptablePhratchMorph >> unusedMediaNameFromBaseName: baseName forMedia: aMedia [
	"Answer an unused name for a new media item with the given base name. Strip off the file extension, if any.  med is the sound or costume media which is currently being renamed."

	| nm i existingNames greatestNum |
	
	
	nm := baseName.
	i := nm indexOf: $..
	i > 1
		ifTrue: [ nm := nm copyFrom: 1 to: i - 1 ].
	nm size = 0
		ifTrue: [ 
			aMedia
				ifNil: [ nm := 'new' localized , '1' ]
				ifNotNil: [ 
					nm := aMedia isImage
						ifTrue: [ self defaultImageMedia mediaName ]
						ifFalse: [ 'sound' localized , '1' ] ] ].
	existingNames := Set new.
	media
		do: [ :m | 
			m = aMedia
				ifFalse: [ existingNames add: (String withAll: m mediaName) ] ].
	
	(nm size > 0 and: [ nm last isDigit ])
		ifFalse: [ 
			(existingNames includes: (nm))
				ifFalse: [ ^ nm ] ].
	i := nm size.
	[ i > 1 and: [ (nm at: i) isDigit ] ] whileTrue: [ i := i - 1 ].
	[ i > 1 and: [ (nm at: i) = Character space ] ] whileTrue: [ i := i - 1 ].
	nm := nm copyFrom: 1 to: i.
	greatestNum := 0.

	existingNames
		do: [ :n | 
			i := n size.
			[ i > 1 and: [ (n at: i) isDigit ] ] whileTrue: [ i := i - 1 ].
			(n copyFrom: 1 to: i-1) = nm
				ifTrue: [ |num|
					i := n indexOf: $..
					i > 1
						ifTrue: [ num := n copyFrom: i+1 to: n size ].
					
					num ifNil:[greatestNum := 0]
						ifNotNil:[greatestNum :=  num asNumber max: greatestNum] ] ].
	^ nm , '.', (greatestNum + 1) printString
]

{ #category : #'debug and other' }
ScriptablePhratchMorph >> updateAfterPopUp [

	PhratchFrameMorph allInstancesDo:[:d | d  updateWorkPane].
	
]

{ #category : #byob }
ScriptablePhratchMorph >> updateCustomBlockDefinitionId: id with: newDef [

	| oldDef |

	oldDef := self definitionFor: id.
	customBlocks removeAllSansError: {oldDef. newDef}.
	self ensureCustomBlockExists: newDef.

	self prototype ifNotNil: [
		(self prototype definitionFor: newDef id) ifNotNil: [
			self ensureOwnBlockExists: newDef]]
]

{ #category : #byob }
ScriptablePhratchMorph >> updateLocalId: id withSpec: newUserSpec [

	"a userSpec has been changed by way of drag'n'drop"

	| def affected sf |
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNil: [^self].
	affected := self instancesOf: id.
	def := self definitionFor: id. 
	def ifNil: [self error: 'block definition not found'. ^ self ].
	def userSpec: newUserSpec.
	affected do: [:eachBlock|
		eachBlock
			color: def blockColor;

			privateSetUserSpec: newUserSpec;
			commandSpec: def commandSpec;
"			userSpec: newUserSpec;"

			addLabel].
	sf blockEditors do: [:be |
		be definition id = id ifTrue: [
			be definition: def
"			be template color: def blockColor.
			be buildVariables "]].

	sf viewerPane categoryChanged: 'variables'.
	#none = def category ifFalse: [
		sf viewerPane categoryChanged: def category asString ].

	WatcherMorph allInstancesDo: [:inst | inst step].
]

{ #category : #private }
ScriptablePhratchMorph >> updateMediaCategory [
	"Update the media category in the viewer, if it is showing."

	| sFrame |
	sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sFrame ifNotNil: [
		sFrame projectModified.
		sFrame updateMediaCategoryFor: self.
		sFrame viewerPane refresh].


]

{ #category : #byob }
ScriptablePhratchMorph >> updateOnlyLocalId: id withSpec: newUserSpec [

	"a userSpec has been changed by way of drag'n'drop
	don't update block editors"

	| def affected sf |
	sf := self ownerOrYourselfThatIsAPhratchFrameMorph.
	sf ifNil: [^self].
	affected := self instancesOf: id.
	def := self definitionFor: id. 
	def userSpec: newUserSpec.
	affected do: [:eachBlock|
		eachBlock
			color: def blockColor;

			privateSetUserSpec: newUserSpec;
			commandSpec: def commandSpec;
			addLabel].

	sf viewerPane categoryChanged: 'variables'.
	#none = def category ifFalse: [
		sf viewerPane categoryChanged: def category asString ].

	WatcherMorph allInstancesDo: [:inst | inst step].
]

{ #category : #variables }
ScriptablePhratchMorph >> varNames [
	"Answer a list of variable names."

	| lst |
	lst := vars keys asSet.
	self prototype ifNotNil: [
		lst addAll: self prototype varNames ].

	^ lst asSet asArray

]

{ #category : #variables }
ScriptablePhratchMorph >> varNamesMenu [
	"Answer a list of variable names."

	| varList stage |
	varList := #().
	(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNotNil: [varList := stage varNames].
	self == stage ifFalse: [
		varList size > 0 ifTrue: [varList := varList copyWith: #-].
		varList := varList, self varNames].

	^ varList
]

{ #category : #variables }
ScriptablePhratchMorph >> variableBlockColor [

	^ Color h: 25 s: 0.88 v: 0.95


]

{ #category : #variables }
ScriptablePhratchMorph >> variableNameInUse: varName [
	"Answer true if the given variable name in the receiver would conflict with an existing variable or list. For example, if the receiver is the Stage and the given variable name is used by any sprite."

	| stage |
	(self allVarNames includes: varName) ifTrue: [^ true].

	self isSprite
		ifTrue: [
			(stage := self ownerOrYourselfThatIsAPhratchStageMorph) ifNil: [^ false].
			^ stage allVarNames includes: varName]
		ifFalse: [
			submorphs do: [:m |
				(m isPhratchSpriteMorph) ifTrue: [
					(m allVarNames includes: varName) ifTrue: [^ true]]]].

	^ false

]

{ #category : #byob }
ScriptablePhratchMorph >> vars [
	^vars
]

{ #category : #blocks }
ScriptablePhratchMorph >> viewBlocksAndScripts [

	| sFrame editor viewer tabs |
	self isClone ifTrue: [^ self].

	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ self].
	editor := sFrame scriptsPane.
	viewer := sFrame viewerPane.
	tabs := sFrame scriptsPane tabPane.
	sFrame view: self tab: tabs currentTab category: viewer currentCategory.

	self world ifNotNil: [
		self zoomRectFrom: self bounds to: editor bounds].

]

{ #category : #byob }
ScriptablePhratchMorph >> viewBlocksAndScriptsQuickly [

	| sFrame viewer tabs |
	self isClone ifTrue: [^ self].

	(sFrame := self ownerOrYourselfThatIsAPhratchFrameMorph) ifNil: [^ self].
	viewer := sFrame viewerPane.
	tabs := sFrame scriptsPane tabPane.
	sFrame view: self tab: tabs currentTab category: viewer currentCategory.

"
	self world ifNotNil: [
		self zoomRectFrom: self bounds to: editor bounds].

"
]

{ #category : #blocks }
ScriptablePhratchMorph >> viewerPageForCategory: aCategoryName [
	"Answer a morph containing blocks for the given category for use in the given PhratchViewer."

	^(PhratchCategory allSubclasses detect:[:e | e label = aCategoryName]) viewerPageFor: self.
]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> visibility [
	"Answer my visibility. 0 is invisible. 100 is fully opaque."

	^ visibility

]

{ #category : #'looks ops' }
ScriptablePhratchMorph >> visibility: aNumber [
	"Set my visibility. 0 is invisible. 100 is fully opaque."

	visibility := (aNumber max: 0) min: 100.
	self changed.

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> wait: duration elapsed: elapsed from: ignored [
	"Do nothing; just wait for the time interval to elapse."
	<phratchItem: 'wait $Number$ secs' kind: #TimeBlockMorph category: 'control' defaultValues: #(1) subCategory: #time special: #()>
	^ nil

]

{ #category : #'other ops' }
ScriptablePhratchMorph >> whenEventReceived [
	"Following blocks are executed when the given event is received"
	<phratchItem: 'when I receive $Event$' kind: #EventHatMorph category: 'control' defaultValues: #() subCategory: #ahat special: #()>
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> whenFlagClicked [
	"Following blocks are executed when the green flag is pressed"
	<phratchItem: 'when $Sprite$ clicked' kind: #StartEventHatMorph category: 'control' defaultValues: #() subCategory: #ahat special: #()>
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> whenKeyPressed [
	"Following blocks are executed when the given key is pressed"
	<phratchItem: 'when $Keys$ key pressed' kind: #KeyEventHatMorph category: 'control' defaultValues: #() subCategory: #ahat special: #()>
]

{ #category : #'other ops' }
ScriptablePhratchMorph >> whenSpriteClicked [
	"Following blocks are executed when the given sprite is clicked"
	<phratchItem: 'when $Sprite$ clicked' kind: #MouseClickEventHatMorph category: 'control' defaultValues: #() subCategory: #ahat special: #()>
]

{ #category : #blocks }
ScriptablePhratchMorph >> wholeBlockSpecForSelector: aSymbol [
	"Answer a block specification string (in English) for the give selector or nil if there is no spec that has the given selector."

	phratchModel class blockSpecs do: [:spec |
		((spec isArray) and: [(spec at: 3) = aSymbol])
			ifTrue: [^ spec]].

	^ nil

]

{ #category : #private }
ScriptablePhratchMorph >> zoomRectFrom: startRect to: finalRect [

	| steps r p1 p2 |
	steps := 8.
	r := startRect.
	Display border: r width: 2 rule: Form reverse fillColor: Color gray.
	Display forceDisplayUpdate.
	0 to: steps do: [:i |
		(Delay forMilliseconds: 35) wait.
		Display border: r width: 2 rule: Form reverse fillColor: Color gray.
		Display forceDisplayUpdate.
		p1 := startRect origin + ((i * (finalRect origin - startRect origin)) // steps).
		p2 := startRect corner + ((i * (finalRect corner - startRect corner)) // steps).
		r := p1 corner: p2.
		Display border: r width: 2 rule: Form reverse fillColor: Color gray.
		Display forceDisplayUpdate].
	(Delay forMilliseconds: 35) wait.
	Display border: r width: 2 rule: Form reverse fillColor: Color gray.
	Display forceDisplayUpdate.

]

{ #category : #byob }
ScriptablePhratchMorph >> | aBoolean [
	"Boolean operator 'OR'"
	<phratchItem: '$Boolean$ or $Boolean$' kind: #BooleanBlockMorph category: 'operators' defaultValues: #() subCategory: #a4 special: #()>

]
